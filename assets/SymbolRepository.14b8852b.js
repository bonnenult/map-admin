var G=Object.defineProperty,B=Object.defineProperties;var K=Object.getOwnPropertyDescriptors;var C=Object.getOwnPropertySymbols;var j=Object.prototype.hasOwnProperty,X=Object.prototype.propertyIsEnumerable;var D=(c,e,s)=>e in c?G(c,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):c[e]=s,k=(c,e)=>{for(var s in e||(e={}))j.call(e,s)&&D(c,s,e[s]);if(C)for(var s of C(e))X.call(e,s)&&D(c,s,e[s]);return c},T=(c,e)=>B(c,K(e));import{cP as A,cT as L,cU as Y,k4 as q,kg as Q,bC as U,eG as J,b8 as Z,c6 as z,kh as O,ki as ee,kj as te,b0 as $,fm as se,b5 as N,kk as H}from"./vendor.c8f3cc8c.js";import{t as w}from"./BidiEngine.aae60613.js";import{j as ie}from"./CIMSymbolHelper.05203bfb.js";class I{constructor(e,s){this._width=0,this._height=0,this._free=[],this._width=e,this._height=s,this._free.push(new w(0,0,e,s))}get width(){return this._width}get height(){return this._height}allocate(e,s){if(e>this._width||s>this._height)return new w;let t=null,i=-1;for(let r=0;r<this._free.length;++r){const n=this._free[r];e<=n.width&&s<=n.height&&(t===null||n.y<=t.y&&n.x<=t.x)&&(t=n,i=r)}return t===null?new w:(this._free.splice(i,1),t.width<t.height?(t.width>e&&this._free.push(new w(t.x+e,t.y,t.width-e,s)),t.height>s&&this._free.push(new w(t.x,t.y+s,t.width,t.height-s))):(t.width>e&&this._free.push(new w(t.x+e,t.y,t.width-e,t.height)),t.height>s&&this._free.push(new w(t.x,t.y+s,e,t.height-s))),new w(t.x,t.y,e,s))}release(e){for(let s=0;s<this._free.length;++s){const t=this._free[s];if(t.y===e.y&&t.height===e.height&&t.x+t.width===e.x)t.width+=e.width;else if(t.x===e.x&&t.width===e.width&&t.y+t.height===e.y)t.height+=e.height;else if(e.y===t.y&&e.height===t.height&&e.x+e.width===t.x)t.x=e.x,t.width+=e.width;else{if(e.x!==t.x||e.width!==t.width||e.y+e.height!==t.y)continue;t.y=e.y,t.height+=e.height}this._free.splice(s,1),this.release(e)}this._free.push(e)}}class W{constructor(e,s,t){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=e,this.height=s,this._glyphSource=t,this._binPack=new I(e-4,s-4),this._glyphData.push(new Uint8Array(e*s)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(e,s){const t=[],i=this._glyphSource,r=new Set,n=1/256;for(const o of s){const h=Math.floor(o*n);r.add(h)}const l=[];return r.forEach(o=>{if(o<=256){const h=e+o;if(this._rangePromises.has(h))l.push(this._rangePromises.get(h));else{const u=i.getRange(e,o).then(()=>{this._rangePromises.delete(h)},()=>{this._rangePromises.delete(h)});this._rangePromises.set(h,u),l.push(u)}}}),Promise.all(l).then(()=>{let o=this._glyphIndex[e];o||(o={},this._glyphIndex[e]=o);for(const h of s){const u=o[h];if(u){t[h]={sdf:!0,rect:u.rect,metrics:u.metrics,page:u.page,code:h};continue}const g=i.getGlyph(e,h);if(!g||!g.metrics)continue;const _=g.metrics;let a;if(_.width===0)a=new w(0,0,0,0);else{const f=3,y=_.width+2*f,p=_.height+2*f;let d=y%4?4-y%4:4,m=p%4?4-p%4:4;d===1&&(d=5),m===1&&(m=5),a=this._binPack.allocate(y+d,p+m),a.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new I(this.width-4,this.height-4),a=this._binPack.allocate(y+d,p+m));const b=this._glyphData[this._currentPage],x=g.bitmap;let P,v;if(x)for(let S=0;S<p;S++){P=y*S,v=this.width*(a.y+S+1)+a.x;for(let R=0;R<y;R++)b[v+R+1]=x[P+R]}}o[h]={rect:a,metrics:_,tileIDs:null,page:this._currentPage},t[h]={sdf:!0,rect:a,metrics:_,page:this._currentPage,code:h},this._dirties[this._currentPage]=!0}return t})}removeGlyphs(e){for(const s in this._glyphIndex){const t=this._glyphIndex[s];if(!t)continue;let i;for(const r in t)if(i=t[r],i.tileIDs.delete(e),i.tileIDs.size===0){const n=this._glyphData[i.page],l=i.rect;let o,h;for(let u=0;u<l.height;u++)for(o=this.width*(l.y+u)+l.x,h=0;h<l.width;h++)n[o+h]=0;delete t[r],this._dirties[i.page]=!0}}}bind(e,s,t,i=0){this._textures[t]||(this._textures[t]=new A(e,{pixelFormat:6406,dataType:5121,width:this.width,height:this.height},new Uint8Array(this.width*this.height)));const r=this._textures[t];r.setSamplingMode(s),this._dirties[t]&&r.setData(this._glyphData[t]),e.bindTexture(r,i),this._dirties[t]=!1}dispose(){this._binPack=null;for(const e of this._textures)e&&e.dispose();this._textures.length=0}}class V{constructor(e){if(this._metrics=[],this._bitmaps=[],e)for(;e.next();)switch(e.tag()){case 1:{const s=e.getMessage();for(;s.next();)switch(s.tag()){case 3:{const t=s.getMessage();let i,r,n,l,o,h,u;for(;t.next();)switch(t.tag()){case 1:i=t.getUInt32();break;case 2:r=t.getBytes();break;case 3:n=t.getUInt32();break;case 4:l=t.getUInt32();break;case 5:o=t.getSInt32();break;case 6:h=t.getSInt32();break;case 7:u=t.getUInt32();break;default:t.skip()}t.release(),i&&(this._metrics[i]={width:n,height:l,left:o,top:h,advance:u},this._bitmaps[i]=r);break}default:s.skip()}s.release();break}default:e.skip()}}getMetrics(e){return this._metrics[e]}getBitmap(e){return this._bitmaps[e]}}class re{constructor(){this._ranges=[]}getRange(e){return this._ranges[e]}addRange(e,s){this._ranges[e]=s}}class E{constructor(e){this._glyphInfo={},this._baseURL=e}getRange(e,s){const t=this._getFontStack(e);if(t.getRange(s))return Promise.resolve();const i=256*s,r=i+255,n=this._baseURL.replace("{fontstack}",e).replace("{range}",i+"-"+r);return L(n,{responseType:"array-buffer"}).then(l=>{t.addRange(s,new V(new Y(new Uint8Array(l.data),new DataView(l.data))))}).catch(()=>{t.addRange(s,new V)})}getGlyph(e,s){const t=this._getFontStack(e);if(!t)return;const i=Math.floor(s/256);if(i>256)return;const r=t.getRange(i);return r?{metrics:r.getMetrics(s),bitmap:r.getBitmap(s)}:void 0}_getFontStack(e){let s=this._glyphInfo[e];return s||(s=this._glyphInfo[e]=new re),s}}const oe="dasharray-";class M{constructor(e,s,t=0){this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,(e<=0||s<=0)&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=e,this._pageHeight=s,t>0&&(this._maxItemSize=t),this._binPack=new I(e-4,s-4)}dispose(){this._binPack=null,this._mosaicRects={};for(const e of this._textures)e&&e.dispose();this._textures.length=0}getWidth(e){return e>=this._size.length?-1:this._size[e][0]}getHeight(e){return e>=this._size.length?-1:this._size[e][1]}getPageSize(e){return e>=this._size.length?null:this._size[e]}setSpriteSource(e){if(this.dispose(),this.pixelRatio=e.devicePixelRatio,this._mosaicsData.length===0){this._binPack=new I(this._pageWidth-4,this._pageHeight-4);const s=Math.floor(this._pageWidth),t=Math.floor(this._pageHeight),i=new Uint32Array(s*t);this._mosaicsData[0]=i,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=e}getSpriteItem(e,s=!1){let t,i,r=this._mosaicRects[e];if(r)return r;if(!this._sprites||this._sprites.loadStatus!=="loaded"||(e&&e.startsWith(oe)?([t,i]=this._rasterizeDash(e),s=!0):t=this._sprites.getSpriteInfo(e),!t||!t.width||!t.height||t.width<0||t.height<0))return null;const n=t.width,l=t.height,[o,h,u]=this._allocateImage(n,l);return o.width<=0?null:(this._copy(o,t,h,u,s,i),r={rect:o,width:n,height:l,sdf:t.sdf,simplePattern:!1,pixelRatio:t.pixelRatio,page:h},this._mosaicRects[e]=r,r)}getSpriteItems(e){const s={};for(const t of e)s[t.name]=this.getSpriteItem(t.name,t.repeat);return s}getMosaicItemPosition(e,s){const t=this.getSpriteItem(e,s),i=t&&t.rect;if(!i)return null;i.width=t.width,i.height=t.height;const r=t.width,n=t.height,l=2;return{tl:[i.x+l,i.y+l],br:[i.x+l+r,i.y+l+n],page:t.page}}bind(e,s,t=0,i=0){this._textures[t]||(this._textures[t]=new A(e,{pixelFormat:6408,dataType:5121,wrapMode:33071,width:this._size[t][0],height:this._size[t][1]},new Uint8Array(this._mosaicsData[t].buffer)));const r=this._textures[t];r.setSamplingMode(s),this._dirties[t]&&r.setData(new Uint8Array(this._mosaicsData[t].buffer)),e.bindTexture(r,i),this._dirties[t]=!1}static _copyBits(e,s,t,i,r,n,l,o,h,u,g){let _=i*s+t,a=o*n+l;if(g){a-=n;for(let f=-1;f<=u;f++,_=((f+u)%u+i)*s+t,a+=n)for(let y=-1;y<=h;y++)r[a+y]=e[_+(y+h)%h]}else for(let f=0;f<u;f++){for(let y=0;y<h;y++)r[a+y]=e[_+y];_+=s,a+=n}}_copy(e,s,t,i,r,n){if(!this._sprites||this._sprites.loadStatus!=="loaded"||t>=this._mosaicsData.length)return;const l=new Uint32Array(n?n.buffer:this._sprites.image.buffer),o=this._mosaicsData[t];o&&l||console.error("Source or target images are uninitialized!");const h=2,u=n?s.width:this._sprites.width;M._copyBits(l,u,s.x,s.y,o,i[0],e.x+h,e.y+h,s.width,s.height,r),this._dirties[t]=!0}_allocateImage(e,s){e+=2,s+=2;const t=Math.max(e,s);if(this._maxItemSize&&this._maxItemSize<t){const l=new w(0,0,e,s);return this._mosaicsData.push(new Uint32Array(e*s)),this._dirties.push(!0),this._size.push([e,s]),this._textures.push(void 0),[l,this._mosaicsData.length-1,[e,s]]}let i=e%4?4-e%4:4,r=s%4?4-s%4:4;i===1&&(i=5),r===1&&(r=5);const n=this._binPack.allocate(e+i,s+r);return n.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new I(this._pageWidth-4,this._pageHeight-4),this._allocateImage(e,s)):[n,this._currentPage,[this._pageWidth,this._pageHeight]]}_rasterizeDash(e){const s=/\[(.*?)\]/,t=e.match(s);if(!t)return null;const i=t[1].split(",").map(Number),r=e.slice(e.lastIndexOf("-")+1),[n,l,o]=ie.rasterizeDash(i,r);return[{x:0,y:0,width:l,height:o,sdf:!0,pixelRatio:1},new Uint8Array(n.buffer)]}}function F(c,e,s,t,i,r){c.fillStyle=e,c.fillRect(s,t,i,r)}function ne(c,e,s,t,i,r){c.strokeStyle=e,c.strokeRect(s,t,i,r)}function me(c,e){const s=window.COLLISION_XRAY;for(let t=0;t<e.length;++t){const i=!e[t].unique.show;if(s||!i)for(const r of e[t].colliders){if(!r.enabled)continue;const n=!e[t].unique.parts[r.partIndex].show;if(!s&&n)continue;const l=r.xScreen,o=r.yScreen,h=r.dxScreen,u=r.dyScreen;c.globalAlpha=i||n?.2:1,F(c,"green",l-1,o-1,3,3),ne(c,"red",l+h,o+u,r.width,r.height),F(c,"blue",l+h-1,o+u-1,3,3),c.globalAlpha=1}}}function le(c,e,s){if(!window.PERFORMANCE_RECORDING_STORAGE)return;const t=window.PERFORMANCE_RECORDING_STORAGE;t.perf=t.perf||{};const i=t.perf;i[c]=i[c]||{start:null,time:0,min:void 0,max:void 0,samples:[],unit:s},i[c].time+=e,i[c].samples.push(e),(i[c].min==null||e<i[c].min)&&(i[c].min=e),(i[c].max==null||e>i[c].max)&&(i[c].max=e)}class be{constructor(e,s,t){this._layer=e,this._styleRepository=s,this.devicePixelRatio=t,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null}destroy(){this._connection&&(this._connection.close(),this._connection=null),this._styleRepository=null,this._layer=null,this._spriteMosaic&&(this._spriteMosaic=null),this._glyphMosaic&&(this._glyphMosaic=null)}get spriteMosaic(){return this._spriteSourcePromise.then(()=>this._spriteMosaic)}get glyphMosaic(){return this._glyphMosaic}async start(e){this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,e),this._spriteSourcePromise.then(t=>{this._spriteMosaic=new M(1024,1024,250),this._spriteMosaic.setSpriteSource(t)});const s=new E(this._layer.currentStyleInfo.glyphsUrl?q(this._layer.currentStyleInfo.glyphsUrl,T(k({},this._layer.customParameters),{token:this._layer.apiKey})):null);this._glyphMosaic=new W(1024,1024,s),this._broadcastPromise=Q("WorkerTileHandler",{client:this,schedule:e.schedule,signal:e.signal}).then(t=>(this._connection=t,Promise.all(this._connection.broadcast("setStyle",{style:this._layer.currentStyleInfo.style,vectorTileLayerMaxBuffers:U("vectortilelayer-max-buffers")},e))))}async updateStyle(e){return await this._broadcastPromise,this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",e)),this._broadcastPromise}async setStyle(e,s){await this._broadcastPromise,this._styleRepository=e,this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,null),this._spriteSourcePromise.then(i=>{this._spriteMosaic=new M(1024,1024,250),this._spriteMosaic.setSpriteSource(i)});const t=new E(this._layer.currentStyleInfo.glyphsUrl?q(this._layer.currentStyleInfo.glyphsUrl,T(k({},this._layer.customParameters),{token:this._layer.apiKey})):null);return this._glyphMosaic=new W(1024,1024,t),this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",{style:s,vectorTileLayerMaxBuffers:U("vectortilelayer-max-buffers")})),this._broadcastPromise}fetchTileData(e,s){return this._getRefKeys(e,s).then(t=>{const i=this._layer.sourceNameToSource,r=[];for(const n in i)r.push(n);return this._getSourcesData(r,t,s)})}parseTileData(e,s){const t=e&&e.data;if(!t)return Promise.resolve(null);const{sourceName2DataAndRefKey:i,transferList:r}=t;return Object.keys(i).length===0?Promise.resolve(null):this._broadcastPromise.then(()=>this._connection.getAvailableClient().then(n=>n.invoke("createTileAndParse",{key:e.key.id,sourceName2DataAndRefKey:i,styleLayerUIDs:e.styleLayerUIDs},T(k({},s),{transferList:r}))))}async getSprites(e){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(e)}getGlyphs(e){return this._glyphMosaic.getGlyphItems(e.font,e.codePoints)}perfReport({key:e,milliseconds:s}){le(e,s,"ms")}async _getTilePayload(e,s,t){const i=J.pool.acquire(e.id),r=this._layer.sourceNameToSource[s].getSourceTileUrl(i.level,i.row,i.col);J.pool.release(i);try{return{protobuff:await this.request(r,t),sourceName:s}}catch(n){if(Z(n))throw n;return{protobuff:null,sourceName:s}}}request(e,s){return L(e,k({responseType:"array-buffer"},s)).then(({data:t})=>t)}_getRefKeys(e,s){const t=this._layer.sourceNameToSource,i=new Array;for(const r in t){const n=t[r].getRefKey(e,s);i.push(n)}return z(i)}_getSourcesData(e,s,t){const i=[];for(let r=0;r<s.length;r++)if(s[r].value==null||e[r]==null)i.push(null);else{const n=this._getTilePayload(s[r].value,e[r],t);i.push(n)}return z(i).then(r=>{const n={},l=[];for(let o=0;o<r.length;o++)if(r[o].value&&r[o].value&&r[o].value.protobuff&&r[o].value.protobuff.byteLength>0){const h=s[o].value.id;n[r[o].value.sourceName]={refKey:h,protobuff:r[o].value.protobuff},l.push(r[o].value.protobuff)}return{sourceName2DataAndRefKey:n,transferList:l}})}}function ae(c,e,s,t,i,r){const{iconRotationAlignment:n,textRotationAlignment:l,iconTranslate:o,iconTranslateAnchor:h,textTranslate:u,textTranslateAnchor:g}=t;let _=0;for(const a of c.colliders){const[f,y]=a.partIndex===0?o:u,p=a.partIndex===0?h:g,d=a.minLod<=r&&r<=a.maxLod;_+=d?0:1,a.enabled=d,a.xScreen=a.xTile*i[0]+a.yTile*i[3]+i[6],a.yScreen=a.xTile*i[1]+a.yTile*i[4]+i[7],p===0?(a.xScreen+=s*f-e*y,a.yScreen+=e*f+s*y):(a.xScreen+=f,a.yScreen+=y),(a.partIndex===0?n:l)===1?(a.dxScreen=a.dxPixels,a.dyScreen=a.dyPixels):(a.dxScreen=s*(a.dxPixels+a.width/2)-e*(a.dyPixels+a.height/2)-a.width/2,a.dyScreen=e*(a.dxPixels+a.width/2)+s*(a.dyPixels+a.height/2)-a.height/2)}c.colliders.length>0&&_===c.colliders.length&&(c.unique.show=!1)}class we{constructor(e,s,t,i,r,n){this._symbols=e,this._styleRepository=i,this._zoom=r,this._currentLayerCursor=0,this._currentSymbolCursor=0,this._styleProps=new Map,this._allNeededMatrices=new Map,this._gridIndex=new O(s,t,ee),this._si=Math.sin(Math.PI*n/180),this._co=Math.cos(Math.PI*n/180);for(const l of e)for(const o of l.symbols)this._allNeededMatrices.has(o.tile)||this._allNeededMatrices.set(o.tile,te(o.tile.transforms.tileUnitsToPixels))}work(e){const s=this._gridIndex;function t(r){const n=r.xScreen+r.dxScreen,l=r.yScreen+r.dyScreen,o=n+r.width,h=l+r.height,[u,g,_,a]=s.getCellSpan(n,l,o,h);for(let f=g;f<=a;f++)for(let y=u;y<=_;y++){const p=s.cells[f][y];for(const d of p){const m=d.xScreen+d.dxScreen,b=d.yScreen+d.dyScreen,x=m+d.width,P=b+d.height;if(!(o<m||n>x||h<b||l>P))return!0}}return!1}const i=performance.now();for(;this._currentLayerCursor<this._symbols.length;this._currentLayerCursor++,this._currentSymbolCursor=0){const r=this._symbols[this._currentLayerCursor],n=this._getProperties(r.styleLayerUID);for(;this._currentSymbolCursor<r.symbols.length;this._currentSymbolCursor++){if(this._currentSymbolCursor%100==99&&performance.now()-i>e)return!1;const l=r.symbols[this._currentSymbolCursor];if(!l.unique.show)continue;ae(l,this._si,this._co,n,this._allNeededMatrices.get(l.tile),this._zoom);const o=l.unique;if(!o.show)continue;const{iconAllowOverlap:h,iconIgnorePlacement:u,textAllowOverlap:g,textIgnorePlacement:_}=n;for(const a of l.colliders){if(!a.enabled)continue;const f=o.parts[a.partIndex];!f.show||!(a.partIndex?g:h)&&t(a)&&(a.hard?o.show=!1:f.show=!1)}if(o.show)for(const a of l.colliders){if(!a.enabled||(a.partIndex?_:u)||!o.parts[a.partIndex].show)continue;const f=a.xScreen+a.dxScreen,y=a.yScreen+a.dyScreen,p=f+a.width,d=y+a.height,[m,b,x,P]=this._gridIndex.getCellSpan(f,y,p,d);for(let v=b;v<=P;v++)for(let S=m;S<=x;S++)this._gridIndex.cells[v][S].push(a)}}}return!0}_getProperties(e){const s=this._styleProps.get(e);if(s)return s;const t=this._zoom,i=this._styleRepository.getStyleLayerByUID(e),r=i.getLayoutValue("symbol-placement",t)!==0;let n=i.getLayoutValue("icon-rotation-alignment",t);n===2&&(n=r?0:1);let l=i.getLayoutValue("text-rotation-alignment",t);l===2&&(l=r?0:1);const o=i.getPaintValue("icon-translate",t),h=i.getPaintValue("icon-translate-anchor",t),u=i.getPaintValue("text-translate",t),g=i.getPaintValue("text-translate-anchor",t),_={iconAllowOverlap:i.getLayoutValue("icon-allow-overlap",t),iconIgnorePlacement:i.getLayoutValue("icon-ignore-placement",t),textAllowOverlap:i.getLayoutValue("text-allow-overlap",t),textIgnorePlacement:i.getLayoutValue("text-ignore-placement",t),iconRotationAlignment:n,textRotationAlignment:l,iconTranslateAnchor:h,iconTranslate:o,textTranslateAnchor:g,textTranslate:u};return this._styleProps.set(e,_),_}}function he(c,e){if(c.priority-e.priority)return c.priority-e.priority;const s=c.tile.key,t=e.tile.key;return s.world-t.world?s.world-t.world:s.level-t.level?s.level-t.level:s.row-t.row?s.row-t.row:s.col-t.col?s.col-t.col:c.xTile-e.xTile?c.xTile-e.xTile:c.yTile-e.yTile}class xe{constructor(e,s,t,i,r,n){this._visibleTiles=e,this._symbolRepository=s,this._createCollisionJob=t,this._assignTileSymbolsOpacity=i,this._symbolLayerSorter=r,this._isLayerVisible=n,this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}get running(){return this._running}setScreenSize(e,s){this._screenWidth===e&&this._screenHeight===s||this.restart(),this._screenWidth=e,this._screenHeight=s}restart(){this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}continue(e){if(this._selectionJob||(this._selectionJob=this._createSelectionJob()),!this._selectionJobCompleted){const s=performance.now();if(!this._selectionJob.work(e)||(this._selectionJobCompleted=!0,(e=Math.max(0,e-(performance.now()-s)))===0))return!1}if(this._collisionJob||(this._collisionJob=this._createCollisionJob(this._selectionJob.sortedSymbols,this._screenWidth,this._screenHeight)),!this._collisionJobCompleted){const s=performance.now();if(!this._collisionJob.work(e)||(this._collisionJobCompleted=!0,(e=Math.max(0,e-(performance.now()-s)))===0))return!1}if(this._opacityJob||(this._opacityJob=this._createOpacityJob()),!this._opacityJobCompleted){const s=performance.now();if(!this._opacityJob.work(e)||(this._opacityJobCompleted=!0,(e=Math.max(0,e-(performance.now()-s)))===0))return!1}return this._running=!1,!0}_createSelectionJob(){const e=this._symbolRepository.uniqueSymbols;for(let o=0;o<e.length;o++){const h=e[o];for(let u=0;u<h.uniqueSymbols.length;u++){const g=h.uniqueSymbols[u];for(const _ of g.tileSymbols)_.selectedForRendering=!1}}const s=[];let t=0,i=0;const r=this._isLayerVisible;function n(o){let h;const u=performance.now();for(;i<e.length;i++,t=0){const g=e[i],_=g.styleLayerUID;if(!r(_)){s[i]||(s[i]={styleLayerUID:_,symbols:[]});continue}s[i]=s[i]||{styleLayerUID:_,symbols:[]};const a=s[i];for(;t<g.uniqueSymbols.length;t++){if(h=g.uniqueSymbols[t],t%100==99&&performance.now()-u>o)return!1;let f=null,y=!1,p=!1;for(const d of h.tileSymbols)if(!p||!y){const m=d.tile;(!f||m.isCoverage||m.neededForCoverage&&!y)&&(f=d,(m.neededForCoverage||m.isCoverage)&&(p=!0),m.isCoverage&&(y=!0))}if(f.selectedForRendering=!0,p){a.symbols.push(f),h.show=!0;for(const d of h.parts)d.show=!0}else h.show=!1}}for(const g of s)g.symbols.sort(he);return!0}const l=this._symbolLayerSorter;return{work:n,get sortedSymbols(){return s.sort(l)}}}_createOpacityJob(){const e=this._assignTileSymbolsOpacity,s=this._visibleTiles;let t=0;function i(r,n){const l=r.symbols;for(const[o,h]of l)ce(h,n);e(r,n);for(const o of r.childrenTiles)i(o,n)}return{work(r){const n=performance.now();for(;t<s.length;t++){if(performance.now()-n>r)return!1;const l=s[t];$(l.parentTile)||i(l,performance.now())}return!0}}}}function ce(c,e){for(const s of c){const t=s.unique;for(const i of t.parts){const r=i.targetOpacity>.5?1:-1;i.startOpacity+=r*((e-i.startTime)/se),i.startOpacity=Math.min(Math.max(i.startOpacity,0),1),i.startTime=e,i.targetOpacity=t.show&&i.show?1:0}}}const ue=32,_e=8,ye=64;class Se{constructor(e,s,t){this.tileCoordRange=e,this._visibleTiles=s,this._createUnique=t,this._tiles=new Map,this._uniqueSymbolsReferences=new Map}get uniqueSymbols(){return N(this._uniqueSymbolLayerArray)&&(this._uniqueSymbolLayerArray=this._createUniqueSymbolLayerArray()),this._uniqueSymbolLayerArray}add(e,s){this._uniqueSymbolLayerArray=null;let t=this._tiles.get(e.id);t||(t={symbols:new Map},this._tiles.set(e.id,t));const i=new Map;if(s)for(const l of s)t.symbols.has(l)&&(i.set(l,t.symbols.get(l)),t.symbols.delete(l));else for(const[l,o]of e.layerData)t.symbols.has(l)&&(i.set(l,t.symbols.get(l)),t.symbols.delete(l));this._removeSymbols(i);const r=e.symbols,n=new Map;for(const[l,o]of r){let h=o.length;if(h>=ue){let u=this.tileCoordRange;do u/=2,h/=4;while(h>_e&&u>ye);const g=new O(this.tileCoordRange,this.tileCoordRange,u);n.set(l,{flat:o,index:g}),t.symbols.set(l,{flat:o,index:g});for(const _ of o)g.getCell(_.xTile,_.yTile).push(_)}else n.set(l,{flat:o}),t.symbols.set(l,{flat:o})}this._addSymbols(e.key,r)}deleteStyleLayers(e){this._uniqueSymbolLayerArray=null;for(const[s,t]of this._tiles){const i=new Map;for(const r of e)t.symbols.has(r)&&(i.set(r,t.symbols.get(r)),t.symbols.delete(r));this._removeSymbols(i),t.symbols.size===0&&this._tiles.delete(s)}}removeTile(e){this._uniqueSymbolLayerArray=null;const s=this._tiles.get(e.id);if(!s)return;const t=new Map;for(const[i,r]of e.symbols)s.symbols.has(i)&&(t.set(i,s.symbols.get(i)),s.symbols.delete(i));this._removeSymbols(t),s.symbols.size===0&&this._tiles.delete(e.id)}_removeSymbols(e){for(const[s,{flat:t}]of e)for(const i of t){const r=i.unique,n=r.tileSymbols,l=n.length-1;for(let o=0;o<l;o++)if(n[o]===i){n[o]=n[l];break}if(n.length=l,l===0){const o=this._uniqueSymbolsReferences.get(s);o.delete(r),o.size===0&&this._uniqueSymbolsReferences.delete(s)}i.unique=null}}_addSymbols(e,s){if(s.size===0)return;const t=this._visibleTiles;for(const i of t)i.parentTile||i.key.world!==e.world||i.key.level===e.level&&!i.key.equals(e)||this._matchSymbols(i,e,s);for(const[i,r]of s)for(const n of r)if(N(n.unique)){const l=this._createUnique();n.unique=l,l.tileSymbols.push(n);let o=this._uniqueSymbolsReferences.get(i);o||(o=new Set,this._uniqueSymbolsReferences.set(i,o)),o.add(l)}}_matchSymbols(e,s,t){if(e.key.level>s.level){const r=e.key.level-s.level;if(e.key.row>>r!==s.row||e.key.col>>r!==s.col)return}if(s.level>e.key.level){const r=s.level-e.key.level;if(s.row>>r!==e.key.row||s.col>>r!==e.key.col)return}if(s.equals(e.key)){for(const r of e.childrenTiles)this._matchSymbols(r,s,t);return}const i=new Map;for(const[r,n]of t){const l=[];for(const g of n){const _=H(this.tileCoordRange,g.xTile,s.level,s.col,e.key.level,e.key.col),a=H(this.tileCoordRange,g.yTile,s.level,s.row,e.key.level,e.key.row);_>=0&&_<this.tileCoordRange&&a>=0&&a<this.tileCoordRange&&l.push({symbol:g,xTransformed:_,yTransformed:a})}const o=[],h=e.key.level<s.level?1:1<<e.key.level-s.level,u=this._tiles.get(e.id).symbols.get(r);if(u){const g=u.flat;for(const _ of l){let a,f=!1;const y=_.xTransformed,p=_.yTransformed;a=$(u.index)?u.index.getCell(y,p):g;const d=_.symbol,m=d.hash;for(const b of a)if(m===b.hash&&Math.abs(y-b.xTile)<=h&&Math.abs(p-b.yTile)<=h){const x=b.unique;d.unique=x,x.tileSymbols.push(d),f=!0;break}f||o.push(d)}}o.length>0&&i.set(r,o)}for(const r of e.childrenTiles)this._matchSymbols(r,s,i)}_createUniqueSymbolLayerArray(){const e=this._uniqueSymbolsReferences,s=new Array(e.size);let t,i=0;for(const[r,n]of e){const l=new Array(n.size);t=0;for(const o of n)l[t++]=o;s[i]={styleLayerUID:r,uniqueSymbols:l},i++}return s}}export{we as a,xe as i,me as o,Se as r,be as u};
