var A=Object.defineProperty;var S=Object.getOwnPropertySymbols;var P=Object.prototype.hasOwnProperty,U=Object.prototype.propertyIsEnumerable;var F=(t,e,s)=>e in t?A(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,m=(t,e)=>{for(var s in e||(e={}))P.call(e,s)&&F(t,s,e[s]);if(S)for(var s of S(e))U.call(e,s)&&F(t,s,e[s]);return t};import{s as I}from"./CircularArray.c3563cef.js";import{t as _,r as c,aI as L,bD as W,J as D,im as B,e as y,i as b,X as O,d as C,io as $,iq as x,an as a,ir as G,d4 as R,bb as M,e0 as J,k as z,$ as j,at as Q,cn as Z,gS as T}from"./index.fe92decb.js";const H="__esri_stream_id__",E="__esri_timestamp__",N=1e3;class re{constructor(e,s,r,o,i=128){this._trackIdToObservations=new Map,this._idCounter=0,this._lastPurge=performance.now(),this._addOrUpdated=new Map,this._removed=[],this._maxAge=0,this._timeInfo=r,this._purgeOptions=o,this.store=e,this.objectIdField=s,this.purgeInterval=i,this._useGeneratedIds=this.objectIdField===H}add(e){if(this._useGeneratedIds){const o=this._nextId();e.attributes[this.objectIdField]=o,e.objectId=o}else e.objectId=e.attributes[this.objectIdField];if(this._addOrUpdated.set(e.objectId,e),this._maxAge=Math.max(this._maxAge,e.attributes[this._timeInfo.startTimeField]),!this._timeInfo.trackIdField)return _(this._trackIdLessObservations)&&(this._trackIdLessObservations=new I(1e5)),void this._trackIdLessObservations.enqueue(e.objectId);const s=e.attributes[this._timeInfo.trackIdField];if(!this._trackIdToObservations.has(s)){const o=c(this._purgeOptions)&&this._purgeOptions.maxObservations!=null?this._purgeOptions.maxObservations:N,i=W(o,0,N);this._trackIdToObservations.set(s,new I(i))}const r=this._trackIdToObservations.get(s).enqueue(e.objectId);c(r)&&(this._addOrUpdated.has(r)?this._addOrUpdated.delete(r):this._removed.push(r))}checkForUpdates(){const e=this._getToAdd(),s=this._getToRemove(),r=performance.now();r-this._lastPurge>=this.purgeInterval&&(this._purge(r),this._lastPurge=r);const o=[];if(c(s))for(const i of s){const d=this.store.removeById(i);c(d)&&o.push(d)}if(c(e))for(const i of e)i.attributes[E]=r,this.store.add(i);(e||o)&&this.store.update(e,o)}_getToAdd(){if(!this._addOrUpdated.size)return null;const e=new Array(this._addOrUpdated.size);let s=0;return this._addOrUpdated.forEach(r=>e[s++]=r),this._addOrUpdated.clear(),e}_getToRemove(){const e=this._removed;return this._removed.length?(this._removed=[],e):null}_nextId(){const e=this._idCounter;return this._idCounter=(this._idCounter+1)%4294967294+1,e}_purge(e){const s=this._purgeOptions;c(s)&&(this._purgeSomeByDisplayCount(s),this._purgeByAge(s),this._purgeByAgeReceived(e,s),this._purgeTracks())}_purgeSomeByDisplayCount(e){if(!e.displayCount)return;let s=this.store.size;if(s>e.displayCount){if(this._timeInfo.trackIdField){for(const r of this._trackIdToObservations.values())if(s>e.displayCount&&r.size){const o=L(r.dequeue());this._removed.push(o),s--}}if(c(this._trackIdLessObservations)){let r=s-e.displayCount;for(;r-- >0;){const o=this._trackIdLessObservations.dequeue();c(o)&&this._removed.push(o)}}}}_purgeByAge(e){var s;if(!e.age||(s=this._timeInfo)==null||!s.startTimeField)return;const r=60*e.age*1e3,o=this._maxAge-r;this.store.forEach(i=>{i.attributes[this._timeInfo.startTimeField]<o&&this._removed.push(i.objectId)})}_purgeByAgeReceived(e,s){if(!s.ageReceived)return;const r=e-60*s.ageReceived*1e3;this.store.forEach(o=>{o.attributes[E]<r&&this._removed.push(o.objectId)})}_purgeTracks(){this._trackIdToObservations.forEach((e,s)=>{e.size===0&&this._trackIdToObservations.delete(s)})}}let w=class extends D.EventedMixin(B){onFeature(t){this.emit("feature",t)}};w=y([b("esri.layers.graphics.sources.connections.StreamConnection")],w);const X=w,h=O.getLogger("esri.layers.graphics.sources.connections.WebSocketConnection");var p;(function(t){t[t.CONNECTING=0]="CONNECTING",t[t.OPEN=1]="OPEN",t[t.CLOSING=2]="CLOSING",t[t.CLOSED=3]="CLOSED"})(p||(p={}));let g=class extends X{constructor(t){super(),this.errorString=null;const{geometryType:e,spatialReference:s,sourceSpatialReference:r}=t;this._config=t,this._featureZScaler=$(e,r,s),this._open()}async _open(){await this._tryCreateWebSocket(),this.destroyed||await this._handshake()}destroy(){c(this._websocket)&&(this._websocket.onopen=null,this._websocket.onclose=null,this._websocket.onerror=null,this._websocket.onmessage=null,this._websocket.close()),this._websocket=null}get connectionStatus(){if(_(this._websocket))return"disconnected";switch(this._websocket.readyState){case p.CONNECTING:case p.OPEN:return"connected";case p.CLOSING:case p.CLOSED:return"disconnected"}}async _tryCreateWebSocket(t=this._config.source.path,e=1e3,s=0){try{if(this.destroyed)return;const r=x(t,this._config.customParameters);this._websocket=await this._createWebSocket(r),this.notifyChange("connectionStatus")}catch(r){const o=e/1e3;return this._config.maxReconnectionAttempts&&s>=this._config.maxReconnectionAttempts?(h.error(new a("websocket-connection","Exceeded maxReconnectionAttempts attempts. No further attempts will be made")),void this.destroy()):(h.error(new a("websocket-connection",`Failed to connect. Attempting to reconnect in ${o}s`,r)),await G(e),this._tryCreateWebSocket(t,Math.min(1.5*e,1e3*this._config.maxReconnectionInterval),s+1))}}_createWebSocket(t){return new Promise((e,s)=>{const r=new WebSocket(t);r.onopen=()=>{if(r.onopen=null,this.destroyed)return r.onclose=null,void r.close();r.onclose=o=>this._onClose(o),r.onerror=o=>this._onError(o),r.onmessage=o=>this._onMessage(o),e(r)},r.onclose=o=>{r.onopen=r.onclose=null,s(o)}})}async _handshake(t=1e4){const e=this._websocket;if(_(e))return;const s=R(),r=e.onmessage,{filter:o,outFields:i,spatialReference:d}=this._config;return s.timeout(t),e.onmessage=u=>{var f;let n=null;try{n=JSON.parse(u.data)}catch{}n&&typeof n=="object"||(h.error(new a("websocket-connection","Protocol violation. Handshake failed - malformed message",u.data)),s.reject(),this.destroy()),((f=n.spatialReference)==null?void 0:f.wkid)!==(d==null?void 0:d.wkid)&&(h.error(new a("websocket-connection",`Protocol violation. Handshake failed - expected wkid of ${d.wkid}`,u.data)),s.reject(),this.destroy()),n.format!=="json"&&(h.error(new a("websocket-connection","Protocol violation. Handshake failed - format is not set",u.data)),s.reject(),this.destroy()),o&&n.filter!==o&&h.error(new a("websocket-connection","Tried to set filter, but server doesn't support it")),i&&n.outFields!==i&&h.error(new a("websocket-connection","Tried to set outFields, but server doesn't support it")),e.onmessage=r,s.resolve()},e.send(JSON.stringify({filter:o,outFields:i,format:"json",spatialReference:{wkid:d.wkid}})),s.promise}_onMessage(t){try{const e=JSON.parse(t.data);if(e.type!=="featureResult")throw new a("websocket-connection","Protocol violation - Expected to find message of type 'featureResult'",e);for(const s of e.features)c(this._featureZScaler)&&this._featureZScaler(s.geometry),this.onFeature(s)}catch(e){return h.error(new a("websocket-connection","Failed to parse message",e)),void this.destroy()}}_onError(t){const e="Encountered an error over WebSocket connection";this._set("errorString",e),h.error("websocket-connection",e)}_onClose(t){this._websocket=null,this.notifyChange("connectionStatus"),t.code!==1e3&&h.error("websocket-connection",`WebSocket closed unexpectedly with error code ${t.code}`),this.destroyed||this._open()}};y([C()],g.prototype,"connectionStatus",null),y([C()],g.prototype,"errorString",void 0),g=y([b("esri.layers.graphics.sources.connections.WebSocketConnection")],g);const l=O.getLogger("esri.layers.graphics.sources.connections.GeoEventConnection"),K=1e4,V={maxQueryDepth:5,maxRecordCountFactor:3};let v=class extends g{constructor(t){super(m(m({},V),t))}async _open(){const t=await this._fetchServiceDefinition(this._config.source);t.timeInfo.trackIdField||l.warn("GeoEvent service was configured without a TrackIdField. This may result in certain functionality being disabled. The purgeOptions.maxObservations property will have no effect.");const e=this._fetchWebSocketUrl(t.streamUrls,this._config.spatialReference);this._buddyServicesQuery||(this._buddyServicesQuery=this._queryBuddyServices()),await this._buddyServicesQuery,await this._tryCreateWebSocket(e);const{filter:s,outFields:r}=this._config;this.destroyed||this._setFilter(s,r)}_onMessage(t){let e;try{e=this._enrich(JSON.parse(t.data)),c(this._featureZScaler)&&this._featureZScaler(e.geometry)}catch(s){return void l.error(new a("geoevent-connection","Failed to parse message",s))}this.onFeature(e)}async _fetchServiceDefinition(t){const e=m({f:"json"},this._config.customParameters),s=M(t.path,{query:e,responseType:"json"}),r=(await s).data;return this._serviceDefinition=r,r}_fetchWebSocketUrl(t,e){const s=t[0],{urls:r,token:o}=s,i=this._inferWebSocketBaseUrl(r);return x(`${i}/subscribe`,{outSR:""+e.wkid,token:o})}_inferWebSocketBaseUrl(t){if(t.length===1)return t[0];for(const e of t)if(e.indexOf("wss")!==-1)return e;return l.error(new a("geoevent-connection","Unable to infer WebSocket url",t)),null}async _setFilter(t,e){const s=this._websocket;if(_(s)||_(t)&&_(e))return;const r=JSON.stringify({filter:this._serializeFilter(t,e)});let o=!1;const i=R(),d=()=>{o||(this.destroyed||this._websocket!==s||l.error(new a("geoevent-connection","Server timed out when setting filter")),i.reject())},u=f=>{const n=JSON.parse(f.data);n.filter&&(n.error&&(l.error(new a("geoevent-connection","Failed to set service filter",n.error)),this._set("errorString",`Could not set service filter - ${n.error}`),i.reject(n.error)),s.onmessage=this._onMessage.bind(this),o=!0,i.resolve())};return s.onmessage=u,s.send(r),setTimeout(d,K),i.promise}_serializeFilter(t,e){const s={};if(_(t)&&_(e))return s;if(c(t)&&t.geometry)try{const r=J(t.geometry);if(r.type!=="extent")throw new a(`Expected extent but found type ${r.type}`);s.geometry=JSON.stringify(r.shiftCentralMeridian())}catch(r){l.error(new a("geoevent-connection","Encountered an error when setting connection geometryDefinition",r))}return c(t)&&t.where&&t.where!=="1 = 1"&&(s.where=t.where),c(e)&&(s.outFields=e.join(",")),s}_enrich(t){if(!this._relatedFeatures)return t;const e=this._serviceDefinition.relatedFeatures.joinField,s=t.attributes[e];if(!this._relatedFeatures.has(s))return l.warn("geoevent-connection","Feature join failed. Is the join field configured correctly?",t),t;const{attributes:r,geometry:o}=this._relatedFeatures.get(s);for(const i in r)t.attributes[i]=r[i];return o&&(t.geometry=o),t.geometry||t.centroid||l.error(new a("geoevent-connection","Found malformed feature - no geometry found",t)),t}async _queryBuddyServices(){try{const{relatedFeatures:t,keepLatestArchive:e}=this._serviceDefinition,s=this._queryRelatedFeatures(t),r=this._queryArchive(e);await s;const o=await r;if(!o)return;for(const i of o.features)this.onFeature(this._enrich(i))}catch(t){l.error(new a("geoevent-connection","Encountered an error when querying buddy services",{error:t}))}}async _queryRelatedFeatures(t){if(!t)return;const e=await this._queryBuddy(t.featuresUrl);this._addRelatedFeatures(e)}async _queryArchive(t){if(t)return this._queryBuddy(t.featuresUrl)}async _queryBuddy(t){const e=new(await import("./index.fe92decb.js").then(function(q){return q.tv})).default({url:t}),{capabilities:s}=await e.load(),r=s.query.supportsMaxRecordCountFactor,o=s.query.supportsPagination,i=s.query.supportsCentroid,d=this._config.maxRecordCountFactor,u=e.capabilities.query.maxRecordCount,f=r?u*d:u,n=new z;if(n.outFields=j(this._config.outFields,["*"]),n.where=j(Q(this._config.filter,"where"),"1=1"),n.returnGeometry=!0,n.returnExceededLimitFeatures=!0,n.outSpatialReference=Z.fromJSON(this._config.spatialReference),i&&(n.returnCentroid=!0),r&&(n.maxRecordCountFactor=d),o)return n.num=f,e.destroy(),this._queryPages(t,n);const k=await T(t,n,this._config.sourceSpatialReference);return e.destroy(),k.data}async _queryPages(t,e,s=[],r=0){e.start=c(e.num)?r*e.num:null;const{data:o}=await T(t,e,this._config.sourceSpatialReference);return o.exceededTransferLimit&&r<this._config.maxQueryDepth?(o.features.forEach(i=>s.push(i)),this._queryPages(t,e,s,r+1)):(s.forEach(i=>o.features.push(i)),o)}_addRelatedFeatures(t){const e=new Map,s=t.features,r=this._serviceDefinition.relatedFeatures.joinField;for(const o of s){const i=o.attributes[r];e.set(i,o)}this._relatedFeatures=e}};v=y([b("esri.layers.graphics.sources.connections.GeoEventConnection")],v);const Y=v;function oe(t,e,s,r,o,i,d,u){const f=t.path.indexOf("wss://")===0||t.path.indexOf("ws://")===0,n={source:t,sourceSpatialReference:e,spatialReference:s,geometryType:r,filter:o,maxReconnectionAttempts:i,maxReconnectionInterval:d,customParameters:u};return f?new g(n):new Y(n)}export{re as h,oe as t};
