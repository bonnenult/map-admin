var k=Object.defineProperty,C=Object.defineProperties;var A=Object.getOwnPropertyDescriptors;var q=Object.getOwnPropertySymbols;var P=Object.prototype.hasOwnProperty,$=Object.prototype.propertyIsEnumerable;var D=(f,e,t)=>e in f?k(f,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):f[e]=t,O=(f,e)=>{for(var t in e||(e={}))P.call(e,t)&&D(f,t,e[t]);if(q)for(var t of q(e))$.call(e,t)&&D(f,t,e[t]);return f},S=(f,e)=>C(f,A(e));import{an as b,lW as W,lg as G,ds as z,t as B,c1 as I,cs as w,r as F,di as Q,dk as L,lX as U,gE as v}from"./index.a1c5dd56.js";import{t as H,n as V}from"./objectIdUtils.8b6ba02d.js";import{m as X}from"./FeatureStore.aa5a6f84.js";import{f as _,g as E}from"./projectionSupport.716154a1.js";import{L as J}from"./QueryEngine.88db6aab.js";import{n as K,u as N,i as Y}from"./clientSideDefaults.82ae6aa8.js";import{y as ee,u as g,d as x,c as T,h as M}from"./sourceUtils.e7a97a6a.js";import"./vendor.c6be4c00.js";import"./index.a0863940.js";/* empty css              */import"./qrcode.0911187d.js";/* empty css                 */import"./PooledRBush.adb2b2e6.js";import"./optimizedFeatureQueryEngineAdapter.07711bad.js";import"./centroid.89738b03.js";import"./json.2d0d6862.js";import"./WhereClause.f28b4275.js";import"./QueryEngineCapabilities.83e56447.js";import"./utils.3ae8edb1.js";import"./ClassBreaksDefinition.334a5542.js";import"./spatialQuerySupport.7479ac53.js";const te=v,ie={xmin:-180,ymin:-90,xmax:180,ymax:90,spatialReference:v},se={hasAttachments:!1,capabilities:"query, editing, create, delete, update",useStandardizedQueries:!0,supportsCoordinatesQuantization:!0,supportsReturningQueryGeometry:!0,advancedQueryCapabilities:{supportsQueryAttachments:!1,supportsStatistics:!0,supportsPercentileStatistics:!0,supportsReturningGeometryCentroid:!0,supportsQueryWithDistance:!0,supportsDistinct:!0,supportsReturningQueryExtent:!0,supportsReturningGeometryProperties:!1,supportsHavingClause:!0,supportsOrderBy:!0,supportsPagination:!0,supportsQueryWithResultType:!1,supportsSqlExpression:!0,supportsDisjointSpatialRel:!0}};function ne(f){return w(f)?f.z!=null:!!f.hasZ}function re(f){return w(f)?f.m!=null:!!f.hasM}class De{constructor(){this._queryEngine=null,this._nextObjectId=null}destroy(){this._queryEngine&&this._queryEngine&&this._queryEngine.destroy(),this._queryEngine=this._fieldsIndex=this._createDefaultAttributes=null}async load(e){const t=[],{features:r}=e,i=this._inferLayerProperties(r,e.fields),l=e.fields||[],p=e.hasM!=null?e.hasM:i.hasM,y=e.hasZ!=null?e.hasZ:i.hasZ,c=!e.spatialReference&&!i.spatialReference,d=c?te:e.spatialReference||i.spatialReference,a=c?ie:null,s=e.geometryType||i.geometryType,m=!s;let u=e.objectIdField||i.objectIdField,o=e.timeInfo;if(!m&&(c&&t.push({name:"feature-layer:spatial-reference-not-found",message:"Spatial reference not provided or found in features. Defaults to WGS84"}),!s))throw new b("feature-layer:missing-property","geometryType not set and couldn't be inferred from the provided features");if(!u)throw new b("feature-layer:missing-property","objectIdField not set and couldn't be found in the provided fields");if(i.objectIdField&&u!==i.objectIdField&&(t.push({name:"feature-layer:duplicated-oid-field",message:`Provided objectIdField "${u}" doesn't match the field name "${i.objectIdField}", found in the provided fields`}),u=i.objectIdField),u&&!i.objectIdField){let n=null;l.some(h=>h.name===u&&(n=h,!0))?(n.type="esriFieldTypeOID",n.editable=!1,n.nullable=!1):l.unshift({alias:u,name:u,type:"esriFieldTypeOID",editable:!1,nullable:!1})}for(const n of l){if(n.name==null&&(n.name=n.alias),n.alias==null&&(n.alias=n.name),!n.name)throw new b("feature-layer:invalid-field-name","field name is missing",{field:n});if(n.name===u&&(n.type="esriFieldTypeOID"),W.jsonValues.indexOf(n.type)===-1)throw new b("feature-layer:invalid-field-type",`invalid type for field "${n.name}"`,{field:n})}const j={};for(const n of l)if(n.type!=="esriFieldTypeOID"&&n.type!=="esriFieldTypeGlobalID"){const h=G(n);h!==void 0&&(j[n.name]=h)}if(this._fieldsIndex=new z(l),this._createDefaultAttributes=K(j,u),o){if(o.startTimeField){const n=this._fieldsIndex.get(o.startTimeField);n?(o.startTimeField=n.name,n.type="esriFieldTypeDate"):o.startTimeField=null}if(o.endTimeField){const n=this._fieldsIndex.get(o.endTimeField);n?(o.endTimeField=n.name,n.type="esriFieldTypeDate"):o.endTimeField=null}if(o.trackIdField){const n=this._fieldsIndex.get(o.trackIdField);n?o.trackIdField=n.name:(o.trackIdField=null,t.push({name:"feature-layer:invalid-timeInfo-trackIdField",message:"trackIdField is missing",details:{timeInfo:o}}))}o.startTimeField||o.endTimeField||(t.push({name:"feature-layer:invalid-timeInfo",message:"startTimeField and endTimeField are missing or invalid",details:{timeInfo:o}}),o=null)}const R={warnings:t,featureErrors:[],layerDefinition:S(O({},se),{drawingInfo:N(s),templates:Y(j),extent:a,geometryType:s,objectIdField:u,fields:l,hasZ:!!y,hasM:!!p,timeInfo:o}),assignedObjectIds:{}};if(this._queryEngine=new J({fields:l,geometryType:s,hasM:p,hasZ:y,objectIdField:u,spatialReference:d,featureStore:new X({geometryType:s,hasM:p,hasZ:y}),timeInfo:o,cacheSpatialQueries:!0}),!r||!r.length)return this._nextObjectId=H,R;const Z=V(u,r);return this._nextObjectId=Z+1,await _(r,d),this._loadInitialFeatures(R,r)}async applyEdits(e){const{spatialReference:t,geometryType:r}=this._queryEngine;return await Promise.all([ee(t,r),_(e.adds,t),_(e.updates,t)]),this._applyEdits(e)}queryFeatures(e,t={}){return this._queryEngine.executeQuery(e,t.signal)}queryFeatureCount(e,t={}){return this._queryEngine.executeQueryForCount(e,t.signal)}queryObjectIds(e,t={}){return this._queryEngine.executeQueryForIds(e,t.signal)}queryExtent(e,t={}){return this._queryEngine.executeQueryForExtent(e,t.signal)}querySnapping(e,t={}){return this._queryEngine.executeQueryForSnapping(e,t.signal)}_inferLayerProperties(e,t){let r,i,l=null,p=null,y=null;for(const c of e){const d=c.geometry;if(!B(d)&&(l||(l=I(d)),p||(p=d.spatialReference),r==null&&(r=ne(d)),i==null&&(i=re(d)),l&&p&&r!=null&&i!=null))break}if(t&&t.length){let c=null;t.some(d=>{const a=d.type==="esriFieldTypeOID",s=!d.type&&d.name&&d.name.toLowerCase()==="objectid";return c=d,a||s})&&(y=c.name)}return{geometryType:l,spatialReference:p,objectIdField:y,hasM:i,hasZ:r}}_loadInitialFeatures(e,t){const{geometryType:r,hasM:i,hasZ:l,objectIdField:p,spatialReference:y,featureStore:c}=this._queryEngine,d=[];for(const a of t){if(a.uid!=null&&(e.assignedObjectIds[a.uid]=-1),a.geometry&&r!==I(a.geometry)){e.featureErrors.push(g("Incorrect geometry type."));continue}const s=this._createDefaultAttributes(),m=x(this._fieldsIndex,s,a.attributes,!0,e.warnings);m?e.featureErrors.push(m):(this._assignObjectId(s,a.attributes,!0),a.attributes=s,a.uid!=null&&(e.assignedObjectIds[a.uid]=a.attributes[p]),F(a.geometry)&&(a.geometry=E(a.geometry,a.geometry.spatialReference,y)),d.push(a))}if(c.addMany(Q([],d,r,l,i,p)),e.layerDefinition.extent=this._queryEngine.fullExtent,e.layerDefinition.timeInfo){const{start:a,end:s}=this._queryEngine.timeExtent;e.layerDefinition.timeInfo.timeExtent=[a,s]}return e}_applyEdits(e){const{adds:t,updates:r,deletes:i}=e,l={addResults:[],deleteResults:[],updateResults:[],uidToObjectId:{}};if(t&&t.length&&this._applyAddEdits(l,t),r&&r.length&&this._applyUpdateEdits(l,r),i&&i.length){for(const p of i)l.deleteResults.push(T(p));this._queryEngine.featureStore.removeManyById(i)}return{fullExtent:this._queryEngine.fullExtent,featureEditResults:l}}_applyAddEdits(e,t){const{addResults:r}=e,{geometryType:i,hasM:l,hasZ:p,objectIdField:y,spatialReference:c,featureStore:d}=this._queryEngine,a=[];for(const s of t){if(s.geometry&&i!==I(s.geometry)){r.push(g("Incorrect geometry type."));continue}const m=this._createDefaultAttributes(),u=x(this._fieldsIndex,m,s.attributes);if(u)r.push(u);else{if(this._assignObjectId(m,s.attributes),s.attributes=m,s.uid!=null){const o=s.attributes[y];e.uidToObjectId[s.uid]=o}F(s.geometry)&&(s.geometry=E(M(s.geometry,c),s.geometry.spatialReference,c)),a.push(s),r.push(T(s.attributes[y]))}}d.addMany(Q([],a,i,p,l,y))}_applyUpdateEdits({updateResults:e},t){const{geometryType:r,hasM:i,hasZ:l,objectIdField:p,spatialReference:y,featureStore:c}=this._queryEngine;for(const d of t){const{attributes:a,geometry:s}=d,m=a&&a[p];if(m==null){e.push(g(`Identifier field ${p} missing`));continue}if(!c.has(m)){e.push(g(`Feature with object id ${m} missing`));continue}const u=L(c.getFeature(m),r,l,i);if(F(s)){if(r!==I(s)){e.push(g("Incorrect geometry type."));continue}u.geometry=E(M(s,y),s.spatialReference,y)}if(a){const o=x(this._fieldsIndex,u.attributes,a);if(o){e.push(o);continue}}c.add(U(u,r,l,i,p)),e.push(T(m))}}_assignObjectId(e,t,r=!1){const i=this._queryEngine.objectIdField;r&&t&&isFinite(t[i])?e[i]=t[i]:e[i]=this._nextObjectId++}}export{De as default};
