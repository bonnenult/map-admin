var E=Object.defineProperty,M=Object.defineProperties;var C=Object.getOwnPropertyDescriptors;var _=Object.getOwnPropertySymbols;var $=Object.prototype.hasOwnProperty,T=Object.prototype.propertyIsEnumerable;var x=(a,e,t)=>e in a?E(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t,w=(a,e)=>{for(var t in e||(e={}))$.call(e,t)&&x(a,t,e[t]);if(_)for(var t of _(e))T.call(e,t)&&x(a,t,e[t]);return a},b=(a,e)=>M(a,C(e));import{X as v,e7 as U,M as B,an as y,e8 as G,bj as H,r as m,b3 as I,e9 as S,bo as A,bY as j,t as L,b8 as D,bu as R}from"./index.988b09cd.js";import{j as O}from"./brushes.0945eb3a.js";import{s as q}from"./Container.b0eab594.js";import{w as c}from"./number.dfbabd3f.js";import{I as d}from"./Utils.56a5b8e8.js";const V=v.getLogger("esri.views.2d.engine.webgl.Mesh2D"),F=a=>{switch(a.BYTES_PER_ELEMENT){case 1:return 5121;case 2:return 5123;case 4:return 5125;default:throw new y("Cannot get DataType of array")}},z=(a,e,t,s)=>{let r=0;for(let i=1;i<t;i++){const n=a[2*(e+i-1)],o=a[2*(e+i-1)+1];r+=(a[2*(e+i)]-n)*(a[2*(e+i)+1]+o)}return s?r>0:r<0},P=({coords:a,lengths:e},t)=>{const s=[];for(let r=0,i=0;r<e.length;i+=e[r],r+=1){const n=i,o=[];for(;r<e.length-1&&z(a,i+e[r],e[r+1],t);r+=1,i+=e[r])o.push(i+e[r]-n);const h=a.slice(2*n,2*(i+e[r])),p=S(h,o,2);for(const l of p)s.push(l+n)}return s};class f{constructor(e,t,s,r=!1){this._cache={},this.vertices=e,this.indices=t,this.primitiveType=s,this.isMapSpace=r}static fromRect({x:e,y:t,width:s,height:r}){const i=e,n=t,o=i+s,h=n+r;return f.fromScreenExtent({xmin:i,ymin:n,xmax:o,ymax:h})}static fromPath(e){const t=U(new B,e.path,!1,!1),s=t.coords,r=new Uint32Array(P(t,!0)),i=new Uint32Array(s.length/2);for(let n=0;n<i.length;n++)i[n]=c(Math.floor(s[2*n]),Math.floor(s[2*n+1]));return new f({geometry:i},r,4)}static fromGeometry(e,t){const s=t.geometry.type;switch(s){case"polygon":return f.fromPolygon(e,t.geometry);case"extent":return f.fromMapExtent(e,t.geometry);default:return V.error(new y("mapview-bad-type",`Unable to create a mesh from type ${s}`,t)),f.fromRect({x:0,y:0,width:1,height:1})}}static fromPolygon(e,t){const s=G(new B,t,!1,!1),r=s.coords,i=new Uint32Array(P(s,!1)),n=new Uint32Array(r.length/2),o=A(),h=A();for(let p=0;p<n.length;p++)H(o,r[2*p],r[2*p+1]),e.toScreen(h,o),n[p]=c(Math.floor(h[0]),Math.floor(h[1]));return new f({geometry:n},i,4,!0)}static fromScreenExtent({xmin:e,xmax:t,ymin:s,ymax:r}){const i={geometry:new Uint32Array([c(e,s),c(t,s),c(e,r),c(e,r),c(t,s),c(t,r)])},n=new Uint32Array([0,1,2,3,4,5]);return new f(i,n,4)}static fromMapExtent(e,t){const[s,r]=e.toScreen([0,0],[t.xmin,t.ymin]),[i,n]=e.toScreen([0,0],[t.xmax,t.ymax]),o={geometry:new Uint32Array([c(s,r),c(i,r),c(s,n),c(s,n),c(i,r),c(i,n)])},h=new Uint32Array([0,1,2,3,4,5]);return new f(o,h,4)}destroy(){m(this._cache.indexBuffer)&&this._cache.indexBuffer.dispose();for(const e in this._cache.vertexBuffers)m(this._cache.vertexBuffers[e])&&this._cache.vertexBuffers[e].dispose()}get elementType(){return F(this.indices)}getIndexBuffer(e,t=35044){return this._cache.indexBuffer||(this._cache.indexBuffer=I.createIndex(e,t,this.indices)),this._cache.indexBuffer}getVertexBuffers(e,t=35044){return this._cache.vertexBuffers||(this._cache.vertexBuffers=Object.keys(this.vertices).reduce((s,r)=>b(w({},s),{[r]:I.createVertex(e,t,this.vertices[r])}),{})),this._cache.vertexBuffers}}const W=v.getLogger("esri.views.2d.engine.webgl.ClippingInfo"),u=a=>parseFloat(a)/100;class g extends j{constructor(e,t){super(),this._clip=t,this._cache={},this.stage=e,this._handle=t.watch("version",()=>this._invalidate()),this.ready()}static fromClipArea(e,t){return new g(e,t)}_destroyGL(){m(this._cache.mesh)&&(this._cache.mesh.destroy(),this._cache.mesh=null),m(this._cache.vao)&&(this._cache.vao.dispose(),this._cache.vao=null)}destroy(){this._destroyGL(),this._handle.remove()}getVAO(e,t,s,r){const[i,n]=t.size;if(this._clip.type!=="geometry"&&this._lastWidth===i&&this._lastHeight===n||(this._lastWidth=i,this._lastHeight=n,this._destroyGL()),L(this._cache.vao)){const o=this._createMesh(t,this._clip),h=o.getIndexBuffer(e),p=o.getVertexBuffers(e);this._cache.mesh=o,this._cache.vao=new D(e,s,r,p,h)}return this._cache.vao}_createTransforms(){return{dvs:R()}}_invalidate(){this._destroyGL(),this.requestRender()}_createScreenRect(e,t){const[s,r]=e.size,i=typeof t.left=="string"?u(t.left)*s:t.left,n=typeof t.right=="string"?u(t.right)*s:t.right,o=typeof t.top=="string"?u(t.top)*r:t.top,h=typeof t.bottom=="string"?u(t.bottom)*r:t.bottom,p=i,l=o;return{x:p,y:l,width:Math.max(s-n-p,0),height:Math.max(r-h-l,0)}}_createMesh(e,t){switch(t.type){case"rect":return f.fromRect(this._createScreenRect(e,t));case"path":return f.fromPath(t);case"geometry":return f.fromGeometry(e,t);default:return W.error(new y("mapview-bad-type","Unable to create ClippingInfo mesh from clip of type: ${clip.type}")),f.fromRect({x:0,y:0,width:1,height:1})}}}class Q extends q{constructor(){super(...arguments),this.name=this.constructor.name}set clips(e){this._clips=e,this.children.forEach(t=>t.clips=e),this._updateClippingInfo()}_createTransforms(){return{dvs:R()}}doRender(e){const t=this.createRenderParams(e),{painter:s,globalOpacity:r,profiler:i,drawPhase:n}=t,o=n===d.LABEL||n===d.HIGHLIGHT?1:r*this.computedOpacity;i.recordContainerStart(this.name),s.beforeRenderLayer(t,this._clippingInfos?255:0,o),this.updateTransforms(e.state),this.renderChildren(t),s.compositeLayer(t,o),i.recordContainerEnd()}renderChildren(e){L(this._renderPasses)&&(this._renderPasses=this.prepareRenderPasses(e.painter));for(const t of this.children)t.beforeRender(e);for(const t of this._renderPasses)try{t.render(e)}catch{}for(const t of this.children)t.afterRender(e)}createRenderParams(e){return e.requireFBO=this.requiresDedicatedFBO,e}prepareRenderPasses(e){return[e.registerRenderPass({name:"clip",brushes:[O.clip],target:()=>this._clippingInfos,drawPhase:d.MAP|d.LABEL|d.LABEL_ALPHA|d.DEBUG|d.HIGHLIGHT})]}updateTransforms(e){for(const t of this.children)t.setTransform(e)}onAttach(){super.onAttach(),this._updateClippingInfo()}onDetach(){super.onDetach(),this._updateClippingInfo()}_updateClippingInfo(){if(m(this._clippingInfos)&&(this._clippingInfos.forEach(t=>t.destroy()),this._clippingInfos=null),!this.stage)return;const e=this._clips;m(e)&&e.length&&(this._clippingInfos=e.items.map(t=>g.fromClipArea(this.stage,t))),this.requestRender()}}export{Q as a};
