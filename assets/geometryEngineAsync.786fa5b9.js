var x=Object.defineProperty,h=Object.defineProperties;var v=Object.getOwnPropertyDescriptors;var d=Object.getOwnPropertySymbols;var S=Object.prototype.hasOwnProperty,R=Object.prototype.propertyIsEnumerable;var w=(e,t,r)=>t in e?x(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,u=(e,t)=>{for(var r in t||(t={}))S.call(t,r)&&w(e,r,t[r]);if(d)for(var r of d(t))R.call(t,r)&&w(e,r,t[r]);return e},f=(e,t)=>h(e,v(t));import{fG as m,kf as O,ap as l}from"./vendor.70daa49e.js";function a(e){var t;return Array.isArray(e)?(t=e[0])==null?void 0:t.spatialReference:e==null?void 0:e.spatialReference}function g(e){return e&&(Array.isArray(e)?e.map(g):e.toJSON?e.toJSON():e)}function c(e){return Array.isArray(e)?e.map(t=>m(t)):m(e)}function E(e,t){let r;return Array.isArray(e)?r=e:(r=[],r.push(e),t!=null&&r.push(t)),r}let p;async function J(){return p||(p=O("geometryEngineWorker",{strategy:"distributed"})),p}async function n(e,t){return(await J()).invoke("executeGEOperation",{operation:e,parameters:g(t)})}function I(e){return n("extendedSpatialReferenceInfo",[e])}async function j(e,t){return c(await n("clip",[a(e),e,t]))}async function z(e,t){return c(await n("cut",[a(e),e,t]))}function D(e,t){return n("contains",[a(e),e,t])}function H(e,t){return n("crosses",[a(e),e,t])}function L(e,t,r){return n("distance",[a(e),e,t,r])}function b(e,t){return n("equals",[a(e),e,t])}function k(e,t){return n("intersects",[a(e),e,t])}function q(e,t){return n("touches",[a(e),e,t])}function B(e,t){return n("within",[a(e),e,t])}function C(e,t){return n("disjoint",[a(e),e,t])}function G(e,t){return n("overlaps",[a(e),e,t])}function $(e,t,r){return n("relate",[a(e),e,t,r])}function W(e){return n("isSimple",[a(e),e])}async function F(e){return c(await n("simplify",[a(e),e]))}async function K(e,t=!1){return c(await n("convexHull",[a(e),e,t]))}async function M(e,t){return c(await n("difference",[a(e),e,t]))}async function P(e,t){return c(await n("symmetricDifference",[a(e),e,t]))}async function U(e,t){return c(await n("intersect",[a(e),e,t]))}async function Q(e,t=null){const r=E(e,t);return c(await n("union",[a(r),r]))}async function T(e,t,r,i,s,o){return c(await n("offset",[a(e),e,t,r,i,s,o]))}async function X(e,t,r,i=!1){const s=[a(e),e,t,r,i];return c(await n("buffer",s))}async function Y(e,t,r,i,s,o){const A=[a(e),e,t,r,i,s,o];return c(await n("geodesicBuffer",A))}async function Z(e,t,r=!0){const i=await n("nearestCoordinate",[a(e),e,t,r]);return f(u({},i),{coordinate:l.fromJSON(i.coordinate)})}async function _(e,t){const r=await n("nearestVertex",[a(e),e,t]);return f(u({},r),{coordinate:l.fromJSON(r.coordinate)})}async function ee(e,t,r,i){return(await n("nearestVertices",[a(e),e,t,r,i])).map(s=>f(u({},s),{coordinate:l.fromJSON(s.coordinate)}))}function y(e){return"xmin"in e?e.center:"x"in e?e:e.extent.center}async function te(e,t,r){var i;if(e==null)throw new Error("Illegal Argument Exception");const s=e.spatialReference;r=(i=r)!=null?i:y(e);const o=e.constructor.fromJSON(await n("rotate",[s,e,t,r]));return o.spatialReference=s,o}async function re(e,t){var r;if(e==null)throw new Error("Illegal Argument Exception");const i=e.spatialReference;t=(r=t)!=null?r:y(e);const s=e.constructor.fromJSON(await n("flipHorizontal",[i,e,t]));return s.spatialReference=i,s}async function ne(e,t){var r;if(e==null)throw new Error("Illegal Argument Exception");const i=e.spatialReference;t=(r=t)!=null?r:y(e);const s=e.constructor.fromJSON(await n("flipVertical",[i,e,t]));return s.spatialReference=i,s}async function ae(e,t,r,i){return c(await n("generalize",[a(e),e,t,r,i]))}async function ie(e,t,r){return c(await n("densify",[a(e),e,t,r]))}async function se(e,t,r,i=0){return c(await n("geodesicDensify",[a(e),e,t,r,i]))}function ce(e,t){return n("planarArea",[a(e),e,t])}function oe(e,t){return n("planarLength",[a(e),e,t])}function ue(e,t,r){return n("geodesicArea",[a(e),e,t,r])}function fe(e,t,r){return n("geodesicLength",[a(e),e,t,r])}export{X as buffer,j as clip,D as contains,K as convexHull,H as crosses,z as cut,ie as densify,M as difference,C as disjoint,L as distance,b as equals,I as extendedSpatialReferenceInfo,re as flipHorizontal,ne as flipVertical,ae as generalize,ue as geodesicArea,Y as geodesicBuffer,se as geodesicDensify,fe as geodesicLength,U as intersect,k as intersects,W as isSimple,Z as nearestCoordinate,_ as nearestVertex,ee as nearestVertices,T as offset,G as overlaps,ce as planarArea,oe as planarLength,$ as relate,te as rotate,F as simplify,P as symmetricDifference,q as touches,Q as union,B as within};
