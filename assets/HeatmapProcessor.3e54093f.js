var F=Object.defineProperty,S=Object.defineProperties;var x=Object.getOwnPropertyDescriptors;var f=Object.getOwnPropertySymbols;var v=Object.prototype.hasOwnProperty,E=Object.prototype.propertyIsEnumerable;var u=(i,e,s)=>e in i?F(i,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):i[e]=s,y=(i,e)=>{for(var s in e||(e={}))v.call(e,s)&&u(i,s,e[s]);if(f)for(var s of f(e))E.call(e,s)&&u(i,s,e[s]);return i},T=(i,e)=>S(i,x(e));import{e as O,i as g,m as C,r as M,c$ as w}from"./index.988b09cd.js";import{r as I}from"./heatmapUtils.f4b44f6a.js";import{o as R}from"./definitions.21e97413.js";import{p as D}from"./BaseProcessor.50e88b85.js";import{l as o}from"./tileUtils.78233d4a.js";import"./vendor.c6be4c00.js";import"./index.25aa0880.js";/* empty css              */import"./qrcode.0911187d.js";/* empty css                 */class n{constructor(e,s){this.offset=e,this.extent=s}}function P(i){const e=i.key,s=new Map,r=256,t=R,a=i.tileInfoView.tileInfo.isWrappable;return s.set(o(e,-1,-1,a).id,new n([-t,-t],[t-r,t-r,t,t])),s.set(o(e,0,-1,a).id,new n([0,-t],[0,t-r,t,t])),s.set(o(e,1,-1,a).id,new n([t,-t],[0,t-r,r,t])),s.set(o(e,-1,0,a).id,new n([-t,0],[t-r,0,t,t])),s.set(o(e,1,0,a).id,new n([t,0],[0,0,r,t])),s.set(o(e,-1,1,a).id,new n([-t,t],[t-r,0,t,r])),s.set(o(e,0,1,a).id,new n([0,t],[0,0,t,r])),s.set(o(e,1,1,a).id,new n([t,t],[0,0,r,r])),s}let h=class extends D{constructor(){super(...arguments),this.type="heatmap",this._tileKeyToFeatureSets=new Map}initialize(){this.handles.add([this.tileStore.on("update",this.onTileUpdate.bind(this))])}async update(i,e){const s=e.schema.processors[0];s.type==="heatmap"&&C(this._schema,s)&&(i.mesh=!0,this._schema=s)}onTileUpdate(i){for(const e of i.removed)this._tileKeyToFeatureSets.delete(e.key.id)}onTileClear(i){const e={clear:!0};return this._tileKeyToFeatureSets.delete(i.key.id),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:i.id,data:e})}async onTileMessage(i,e,s){this._tileKeyToFeatureSets.has(i.key.id)||this._tileKeyToFeatureSets.set(i.key.id,new Map);const r=this._tileKeyToFeatureSets.get(i.key.id);if(M(e.addOrUpdate)&&e.addOrUpdate.hasFeatures&&r.set(e.addOrUpdate.instance,e),e.end){const t=[],a=P(i);this._tileKeyToFeatureSets.forEach((m,d)=>{if(d===i.key.id)m.forEach(l=>w(l.addOrUpdate,c=>t.push(c)));else if(a.has(d)){const l=a.get(d),[c,K]=l.offset;m.forEach(_=>w(_.addOrUpdate,U=>{const b=U.transform(c,K,1,1);t.push(b)}))}});const p=I(t,this._schema.mesh,512,512),k={tileKey:i.key.id,intensityInfo:p},j=[p.matrix];return this.remoteClient.invoke("tileRenderer.onTileData",k,T(y({},s),{transferList:j}))}}onTileError(i,e,s){return this.remoteClient.invoke("tileRenderer.onTileError",{tileKey:i.id,error:e},s)}};h=O([g("esri.views.2d.layers.features.processors.HeatmapProcessor")],h);const N=h;export{N as default};
