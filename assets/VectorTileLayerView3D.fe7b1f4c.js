import{iv as q,iw as D,c_ as E,r as m,T as k,aP as V,ix as B,iy as U,iz as z,b$ as R,ee as O,ef as F,eg as G,t as A,an as W,h8 as K,bg as J,b as H,e as u,d as g,i as N}from"./index.a1c5dd56.js";import{s as Q}from"./SchemaHelper.975d616e.js";import{r as X,i as Y,a as Z,u as ee}from"./SymbolRepository.9331d21c.js";import{G as te}from"./brushes.72191f86.js";import{c as ie}from"./VTLMaterialManager.ce18865b.js";import{a as M}from"./StyleRepository.c74906f2.js";import"./vendor.c6be4c00.js";import"./index.a0863940.js";/* empty css              */import"./qrcode.0911187d.js";/* empty css                 */import"./BidiEngine.aae60613.js";import"./CIMSymbolHelper.a880d9c5.js";import"./definitions.21e97413.js";import"./number.dfbabd3f.js";import"./GeometryUtils.d4e26b77.js";import"./Utils.bc20347e.js";import"./programUtils.44a18329.js";import"./GeometryUtils.ea8c8742.js";import"./MaterialKey.89cee420.js";import"./pixelUtils.41f8268c.js";import"./colorUtils.92e1b957.js";function se(l,t){const i=[],r=new X(4096,i,()=>{const s=new q;return s.show=!1,s.parts.push({startTime:0,startOpacity:0,targetOpacity:0,show:!1}),s.parts.push({startTime:0,startOpacity:0,targetOpacity:0,show:!1}),s}),a=new Y(i,r,(s,e,n)=>new Z(s,e,n,l.styleRepository,l.key.level,0),(s,e)=>{D(s,e,!1)},()=>0,s=>{const e=t.getStyleLayerByUID(s).getLayoutProperty("visibility");return!e||e.getValue()!==1});i.push(l),r.add(l),a.setScreenSize(512,512),a.continue(1/0)}class j extends ee{constructor(t,i,r,a,s){super(t,i,r),this._memCache=a,this._loader=s,this._ongoingTileRequests=new Map,this._ongoingRequestToController=new Map}destroy(){this._ongoingRequestToController.forEach(t=>t.abort()),this._ongoingRequestToController.clear(),this._ongoingTileRequests.clear()}async getVectorTile(t,i,r,a){const s=new E(t,i,r,0);let e=this._memCache.get(s.id);if(m(e))return e.retain(),e;const n=await this._getVectorTileData(s);if(k(a),!this._layer)return null;if(e=this._memCache.get(s.id),m(e))return e.retain(),e;const d=this._layer.tileInfo.getTileBounds(V(),s);return e=new B(s,d[0],d[3],512,512,this._styleRepository,this._memCache),m(n)?(e.setData(n),e.retain(),this._memCache.put(s.id,e,e.memoryUsage*e.referenced,U)):e.setData(null),e.neededForCoverage=!0,e.transforms.tileUnitsToPixels=z(1/8,0,0,0,1/8,0,0,0,1),se(e,this._styleRepository),e}_getVectorTileData(t){const i=t.id;if(this._ongoingTileRequests.has(i))return this._ongoingTileRequests.get(i);const r=new AbortController,a={signal:r.signal},s=this._getParsedVectorTileData(t,a).then(e=>(this._ongoingTileRequests.delete(i),this._ongoingRequestToController.delete(i),e)).catch(()=>(this._ongoingTileRequests.delete(i),this._ongoingRequestToController.delete(i),null));return this._ongoingTileRequests.set(i,s),this._ongoingRequestToController.set(i,r),s}_getParsedVectorTileData(t,i){return this.fetchTileData(t,i).then(r=>this.parseTileData({key:t,data:r},i))}request(t,i){return this._loader.request(t,"binary",i)}}const S=1e-6;class ${constructor(t,i){this.spriteMosaic=t,this.glyphMosaic=i,this._brushCache=new Map,this._vtlMaterialManager=new ie}dispose(){this._brushCache&&(this._brushCache.forEach(t=>t.dispose()),this._brushCache=null),this._vtlMaterialManager=R(this._vtlMaterialManager),this.spriteMosaic.dispose(),this.glyphMosaic.dispose()}get vectorTilesMaterialManager(){return this._vtlMaterialManager}drawTile(t,i,r){const{context:a}=t,s=r.layers;r.backgroundBucketIds.length>0&&(t.renderPass="background",r.backgroundBucketIds.forEach(e=>this._renderStyleLayer(r.getLayerById(e),t,i,!0))),a.setBlendingEnabled(!1),a.setDepthTestEnabled(!0),a.setDepthWriteEnabled(!0),a.setDepthFunction(515),t.renderPass="opaque";for(let e=s.length-1;e>=0;e--)this._renderStyleLayer(s[e],t,i,!1);a.setDepthWriteEnabled(!1),a.setBlendingEnabled(!0),a.setBlendFunctionSeparate(1,771,1,771),t.renderPass="translucent";for(let e=0;e<s.length;e++)this._renderStyleLayer(s[e],t,i,!1);a.setDepthTestEnabled(!1),t.renderPass="symbol";for(let e=0;e<s.length;e++)this._renderStyleLayer(s[e],t,i,!1);a.bindVAO()}_renderStyleLayer(t,i,r,a=!1){if(!(a||t&&r.layerData.has(t.uid)))return;const s=t.getLayoutProperty("visibility");if(s&&s.getValue()===1)return;const{renderPass:e}=i;let n;switch(t.type){case 0:if(e!=="background")return;n="vtlBackground";break;case 1:if(e!=="opaque"&&i.renderPass!=="translucent")return;n="vtlFill";break;case 2:if(e!=="translucent")return;n="vtlLine";break;case 4:if(e!=="symbol")return;n="vtlCircle";break;case 3:if(e!=="symbol")return;n="vtlSymbol"}const d=i.displayLevel;t.minzoom!==void 0&&t.minzoom>d+S||t.maxzoom!==void 0&&t.maxzoom<=d-S||(i.styleLayerUID=t.uid,i.styleLayer=t,this.drawWithBrush(i,r,n))}drawWithBrush(t,i,r){if(!this._brushCache.has(r)){const a=te[r];this._brushCache.set(r,new a)}this._brushCache.get(r).drawMany(t,[i])}}let c=class extends O(F(G)){constructor(){super(...arguments),this.type="vector-tile-3d"}initialize(){if(A(this.layer.fullExtent))return void this.addResolvingPromise(Promise.reject(new W("vectortilelayerview:full-extent-undefined","This layer view's layer does not define a fullExtent.")));const l=this.layer.compatibleTileInfo256,t=this._getTileInfoSupportError(l,this.layer.fullExtent);if(t)return this.addResolvingPromise(Promise.reject(t));const{basemapTerrain:i,spatialReference:r,pixelRatio:a}=this.view,s=K(this.view,"basemapTerrain.tilingSchemeLocked").then(()=>{const o=i.tilingScheme,y=o.pixelSize;let h;this.schemaHelper=new Q(y,r.isGeographic),h=y===256?this.layer.compatibleTileInfo256:this.view.spatialReference.isGeographic?this.layer.compatibleTileInfo512:this.layer.tileInfo;const p=this._getTileInfoCompatibilityError(h,o);if(p)throw p;this._set("tileInfo",h)});this._tileHandlerController=new AbortController;const e=this.view.resourceController;this._memCache=e.memoryController.newCache(this.layer.uid,o=>{o.release()});const{style:n}=this.layer.currentStyleInfo,d=new M(n),_=i.mapTileRequester;this._tileHandler=new j(this.layer,d,a,this._memCache,_);const f=this._tileHandlerController.signal,b=o=>e.schedule(o),C=this._tileHandler.start({signal:f,schedule:b}),w=this._tileHandler.spriteMosaic;w.then(o=>{!J(f)&&this._tileHandler&&(this.painter=new $(o,this._tileHandler.glyphMosaic))}),C.then(()=>this._tileHandlerController=null);const T=()=>{this._tileHandlerController&&this._tileHandlerController.abort(),this._tileHandlerController=new AbortController,this._memCache.clear();const{style:o}=this.layer.currentStyleInfo,y=new M(o),h=new j(this.layer,y,a,this._memCache,_),p=h.start({signal:this._tileHandlerController.signal,schedule:b}),P=h.spriteMosaic;p.then(()=>this._tileHandlerController=null),this.updatingHandles.addPromise(Promise.all([p,P]).then(([,I])=>{const L=this._tileHandler,v=this.painter;this.painter=new $(I,h.glyphMosaic),this._tileHandler=h,this.emit("data-changed"),L.destroy(),v&&v.dispose()}))};this.updatingHandles.add(this,"layer.currentStyleInfo",T),this.updatingHandles.add(this,"view.pixelRatio",T);const x=Promise.all([s,C,w]);this.addResolvingPromise(x)}destroy(){this.painter=R(this.painter),this._tileHandlerController&&(this._tileHandlerController.abort(),this._tileHandlerController=null),H(this._tileHandler),this._memCache=H(this._memCache),this._tileHandler=null}get dataLevelRange(){const l=this.tileInfo.lods,t=l[0].scale,i=l[l.length-1].scale,r=this.levelRangeFromScaleRange(t,i);return r.minLevel===1&&this.tileInfo.size[0]===256&&(r.minLevel=0),r}async fetchTile(l,t,i,r){return this._tileHandler.getVectorTile(l,t,i,r)}};u([g({aliasOf:"layer.fullExtent"})],c.prototype,"fullExtent",void 0),u([g()],c.prototype,"layer",void 0),u([g()],c.prototype,"tileInfo",void 0),u([g()],c.prototype,"dataLevelRange",null),u([g()],c.prototype,"updatingProgressValue",void 0),c=u([N("esri.views.3d.layers.VectorTileLayerView3D")],c);const Me=c;export{Me as default};
