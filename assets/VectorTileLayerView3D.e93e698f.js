import{k8 as q,k9 as x,eF as D,a$ as m,bz as E,cu as V,ka as B,kb as U,kc as z,dH as R,fU as F,fV as O,fW as W,b4 as G,c3 as A,iP as X,cX as K,b8 as H,aW as u,aX as g,aY as Y}from"./vendor.70daa49e.js";import{s as J}from"./SchemaHelper.c3756f87.js";import{r as N,i as Q,a as Z,u as ee}from"./SymbolRepository.4d08f9fb.js";import{G as te}from"./brushes.00614641.js";import{c as se}from"./VTLMaterialManager.754cfbe0.js";import{a as M}from"./StyleRepository.4351ecd2.js";import"./BidiEngine.aae60613.js";import"./CIMSymbolHelper.8e5a45e2.js";import"./definitions.21e97413.js";import"./number.dfbabd3f.js";import"./GeometryUtils.d4e26b77.js";import"./Utils.8da54d2f.js";import"./programUtils.96aa856a.js";import"./GeometryUtils.ea8c8742.js";import"./MaterialKey.f8f54134.js";import"./pixelUtils.59d1e551.js";import"./colorUtils.92e1b957.js";function ie(l,t){const s=[],r=new N(4096,s,()=>{const i=new q;return i.show=!1,i.parts.push({startTime:0,startOpacity:0,targetOpacity:0,show:!1}),i.parts.push({startTime:0,startOpacity:0,targetOpacity:0,show:!1}),i}),a=new Q(s,r,(i,e,n)=>new Z(i,e,n,l.styleRepository,l.key.level,0),(i,e)=>{x(i,e,!1)},()=>0,i=>{const e=t.getStyleLayerByUID(i).getLayoutProperty("visibility");return!e||e.getValue()!==1});s.push(l),r.add(l),a.setScreenSize(512,512),a.continue(1/0)}class S extends ee{constructor(t,s,r,a,i){super(t,s,r),this._memCache=a,this._loader=i,this._ongoingTileRequests=new Map,this._ongoingRequestToController=new Map}destroy(){this._ongoingRequestToController.forEach(t=>t.abort()),this._ongoingRequestToController.clear(),this._ongoingTileRequests.clear()}async getVectorTile(t,s,r,a){const i=new D(t,s,r,0);let e=this._memCache.get(i.id);if(m(e))return e.retain(),e;const n=await this._getVectorTileData(i);if(E(a),!this._layer)return null;if(e=this._memCache.get(i.id),m(e))return e.retain(),e;const d=this._layer.tileInfo.getTileBounds(V(),i);return e=new B(i,d[0],d[3],512,512,this._styleRepository,this._memCache),m(n)?(e.setData(n),e.retain(),this._memCache.put(i.id,e,e.memoryUsage*e.referenced,U)):e.setData(null),e.neededForCoverage=!0,e.transforms.tileUnitsToPixels=z(1/8,0,0,0,1/8,0,0,0,1),ie(e,this._styleRepository),e}_getVectorTileData(t){const s=t.id;if(this._ongoingTileRequests.has(s))return this._ongoingTileRequests.get(s);const r=new AbortController,a={signal:r.signal},i=this._getParsedVectorTileData(t,a).then(e=>(this._ongoingTileRequests.delete(s),this._ongoingRequestToController.delete(s),e)).catch(()=>(this._ongoingTileRequests.delete(s),this._ongoingRequestToController.delete(s),null));return this._ongoingTileRequests.set(s,i),this._ongoingRequestToController.set(s,r),i}_getParsedVectorTileData(t,s){return this.fetchTileData(t,s).then(r=>this.parseTileData({key:t,data:r},s))}request(t,s){return this._loader.request(t,"binary",s)}}const $=1e-6;class P{constructor(t,s){this.spriteMosaic=t,this.glyphMosaic=s,this._brushCache=new Map,this._vtlMaterialManager=new se}dispose(){this._brushCache&&(this._brushCache.forEach(t=>t.dispose()),this._brushCache=null),this._vtlMaterialManager=R(this._vtlMaterialManager),this.spriteMosaic.dispose(),this.glyphMosaic.dispose()}get vectorTilesMaterialManager(){return this._vtlMaterialManager}drawTile(t,s,r){const{context:a}=t,i=r.layers;r.backgroundBucketIds.length>0&&(t.renderPass="background",r.backgroundBucketIds.forEach(e=>this._renderStyleLayer(r.getLayerById(e),t,s,!0))),a.setBlendingEnabled(!1),a.setDepthTestEnabled(!0),a.setDepthWriteEnabled(!0),a.setDepthFunction(515),t.renderPass="opaque";for(let e=i.length-1;e>=0;e--)this._renderStyleLayer(i[e],t,s,!1);a.setDepthWriteEnabled(!1),a.setBlendingEnabled(!0),a.setBlendFunctionSeparate(1,771,1,771),t.renderPass="translucent";for(let e=0;e<i.length;e++)this._renderStyleLayer(i[e],t,s,!1);a.setDepthTestEnabled(!1),t.renderPass="symbol";for(let e=0;e<i.length;e++)this._renderStyleLayer(i[e],t,s,!1);a.bindVAO()}_renderStyleLayer(t,s,r,a=!1){if(!(a||t&&r.layerData.has(t.uid)))return;const i=t.getLayoutProperty("visibility");if(i&&i.getValue()===1)return;const{renderPass:e}=s;let n;switch(t.type){case 0:if(e!=="background")return;n="vtlBackground";break;case 1:if(e!=="opaque"&&s.renderPass!=="translucent")return;n="vtlFill";break;case 2:if(e!=="translucent")return;n="vtlLine";break;case 4:if(e!=="symbol")return;n="vtlCircle";break;case 3:if(e!=="symbol")return;n="vtlSymbol"}const d=s.displayLevel;t.minzoom!==void 0&&t.minzoom>d+$||t.maxzoom!==void 0&&t.maxzoom<=d-$||(s.styleLayerUID=t.uid,s.styleLayer=t,this.drawWithBrush(s,r,n))}drawWithBrush(t,s,r){if(!this._brushCache.has(r)){const a=te[r];this._brushCache.set(r,new a)}this._brushCache.get(r).drawMany(t,[s])}}let c=class extends F(O(W)){constructor(){super(...arguments),this.type="vector-tile-3d"}initialize(){if(G(this.layer.fullExtent))return void this.addResolvingPromise(Promise.reject(new A("vectortilelayerview:full-extent-undefined","This layer view's layer does not define a fullExtent.")));const l=this.layer.compatibleTileInfo256,t=this._getTileInfoSupportError(l,this.layer.fullExtent);if(t)return this.addResolvingPromise(Promise.reject(t));const{basemapTerrain:s,spatialReference:r,pixelRatio:a}=this.view,i=X(this.view,"basemapTerrain.tilingSchemeLocked").then(()=>{const o=s.tilingScheme,y=o.pixelSize;let h;this.schemaHelper=new J(y,r.isGeographic),h=y===256?this.layer.compatibleTileInfo256:this.view.spatialReference.isGeographic?this.layer.compatibleTileInfo512:this.layer.tileInfo;const p=this._getTileInfoCompatibilityError(h,o);if(p)throw p;this._set("tileInfo",h)});this._tileHandlerController=new AbortController;const e=this.view.resourceController;this._memCache=e.memoryController.newCache(this.layer.uid,o=>{o.release()});const{style:n}=this.layer.currentStyleInfo,d=new M(n),_=s.mapTileRequester;this._tileHandler=new S(this.layer,d,a,this._memCache,_);const f=this._tileHandlerController.signal,b=o=>e.schedule(o),C=this._tileHandler.start({signal:f,schedule:b}),w=this._tileHandler.spriteMosaic;w.then(o=>{!K(f)&&this._tileHandler&&(this.painter=new P(o,this._tileHandler.glyphMosaic))}),C.then(()=>this._tileHandlerController=null);const T=()=>{this._tileHandlerController&&this._tileHandlerController.abort(),this._tileHandlerController=new AbortController,this._memCache.clear();const{style:o}=this.layer.currentStyleInfo,y=new M(o),h=new S(this.layer,y,a,this._memCache,_),p=h.start({signal:this._tileHandlerController.signal,schedule:b}),I=h.spriteMosaic;p.then(()=>this._tileHandlerController=null),this.updatingHandles.addPromise(Promise.all([p,I]).then(([,L])=>{const k=this._tileHandler,v=this.painter;this.painter=new P(L,h.glyphMosaic),this._tileHandler=h,this.emit("data-changed"),k.destroy(),v&&v.dispose()}))};this.updatingHandles.add(this,"layer.currentStyleInfo",T),this.updatingHandles.add(this,"view.pixelRatio",T);const j=Promise.all([i,C,w]);this.addResolvingPromise(j)}destroy(){this.painter=R(this.painter),this._tileHandlerController&&(this._tileHandlerController.abort(),this._tileHandlerController=null),H(this._tileHandler),this._memCache=H(this._memCache),this._tileHandler=null}get dataLevelRange(){const l=this.tileInfo.lods,t=l[0].scale,s=l[l.length-1].scale,r=this.levelRangeFromScaleRange(t,s);return r.minLevel===1&&this.tileInfo.size[0]===256&&(r.minLevel=0),r}async fetchTile(l,t,s,r){return this._tileHandler.getVectorTile(l,t,s,r)}};u([g({aliasOf:"layer.fullExtent"})],c.prototype,"fullExtent",void 0),u([g()],c.prototype,"layer",void 0),u([g()],c.prototype,"tileInfo",void 0),u([g()],c.prototype,"dataLevelRange",null),u([g()],c.prototype,"updatingProgressValue",void 0),c=u([Y("esri.views.3d.layers.VectorTileLayerView3D")],c);const we=c;export{we as default};
