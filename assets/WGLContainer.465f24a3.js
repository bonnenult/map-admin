var E=Object.defineProperty,C=Object.defineProperties;var M=Object.getOwnPropertyDescriptors;var _=Object.getOwnPropertySymbols;var $=Object.prototype.hasOwnProperty,T=Object.prototype.propertyIsEnumerable;var x=(o,e,t)=>e in o?E(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,w=(o,e)=>{for(var t in e||(e={}))$.call(e,t)&&x(o,t,e[t]);if(_)for(var t of _(e))T.call(e,t)&&x(o,t,e[t]);return o},v=(o,e)=>C(o,M(e));import{bE as b,fO as U,bv as B,c4 as y,fP as G,c$ as H,b0 as m,cL as I,fQ as S,d4 as A,dF as j,b5 as L,cQ as D,da as P}from"./vendor.c8f3cc8c.js";import{j as O}from"./brushes.97799122.js";import{s as q}from"./Container.98366c00.js";import{w as c}from"./number.dfbabd3f.js";import{I as d}from"./Utils.b2b84829.js";const F=b.getLogger("esri.views.2d.engine.webgl.Mesh2D"),V=o=>{switch(o.BYTES_PER_ELEMENT){case 1:return 5121;case 2:return 5123;case 4:return 5125;default:throw new y("Cannot get DataType of array")}},z=(o,e,t,s)=>{let r=0;for(let i=1;i<t;i++){const n=o[2*(e+i-1)],a=o[2*(e+i-1)+1];r+=(o[2*(e+i)]-n)*(o[2*(e+i)+1]+a)}return s?r>0:r<0},R=({coords:o,lengths:e},t)=>{const s=[];for(let r=0,i=0;r<e.length;i+=e[r],r+=1){const n=i,a=[];for(;r<e.length-1&&z(o,i+e[r],e[r+1],t);r+=1,i+=e[r])a.push(i+e[r]-n);const h=o.slice(2*n,2*(i+e[r])),p=S(h,a,2);for(const l of p)s.push(l+n)}return s};class f{constructor(e,t,s,r=!1){this._cache={},this.vertices=e,this.indices=t,this.primitiveType=s,this.isMapSpace=r}static fromRect({x:e,y:t,width:s,height:r}){const i=e,n=t,a=i+s,h=n+r;return f.fromScreenExtent({xmin:i,ymin:n,xmax:a,ymax:h})}static fromPath(e){const t=U(new B,e.path,!1,!1),s=t.coords,r=new Uint32Array(R(t,!0)),i=new Uint32Array(s.length/2);for(let n=0;n<i.length;n++)i[n]=c(Math.floor(s[2*n]),Math.floor(s[2*n+1]));return new f({geometry:i},r,4)}static fromGeometry(e,t){const s=t.geometry.type;switch(s){case"polygon":return f.fromPolygon(e,t.geometry);case"extent":return f.fromMapExtent(e,t.geometry);default:return F.error(new y("mapview-bad-type",`Unable to create a mesh from type ${s}`,t)),f.fromRect({x:0,y:0,width:1,height:1})}}static fromPolygon(e,t){const s=G(new B,t,!1,!1),r=s.coords,i=new Uint32Array(R(s,!1)),n=new Uint32Array(r.length/2),a=A(),h=A();for(let p=0;p<n.length;p++)H(a,r[2*p],r[2*p+1]),e.toScreen(h,a),n[p]=c(Math.floor(h[0]),Math.floor(h[1]));return new f({geometry:n},i,4,!0)}static fromScreenExtent({xmin:e,xmax:t,ymin:s,ymax:r}){const i={geometry:new Uint32Array([c(e,s),c(t,s),c(e,r),c(e,r),c(t,s),c(t,r)])},n=new Uint32Array([0,1,2,3,4,5]);return new f(i,n,4)}static fromMapExtent(e,t){const[s,r]=e.toScreen([0,0],[t.xmin,t.ymin]),[i,n]=e.toScreen([0,0],[t.xmax,t.ymax]),a={geometry:new Uint32Array([c(s,r),c(i,r),c(s,n),c(s,n),c(i,r),c(i,n)])},h=new Uint32Array([0,1,2,3,4,5]);return new f(a,h,4)}destroy(){m(this._cache.indexBuffer)&&this._cache.indexBuffer.dispose();for(const e in this._cache.vertexBuffers)m(this._cache.vertexBuffers[e])&&this._cache.vertexBuffers[e].dispose()}get elementType(){return V(this.indices)}getIndexBuffer(e,t=35044){return this._cache.indexBuffer||(this._cache.indexBuffer=I.createIndex(e,t,this.indices)),this._cache.indexBuffer}getVertexBuffers(e,t=35044){return this._cache.vertexBuffers||(this._cache.vertexBuffers=Object.keys(this.vertices).reduce((s,r)=>v(w({},s),{[r]:I.createVertex(e,t,this.vertices[r])}),{})),this._cache.vertexBuffers}}const Q=b.getLogger("esri.views.2d.engine.webgl.ClippingInfo"),u=o=>parseFloat(o)/100;class g extends j{constructor(e,t){super(),this._clip=t,this._cache={},this.stage=e,this._handle=t.watch("version",()=>this._invalidate()),this.ready()}static fromClipArea(e,t){return new g(e,t)}_destroyGL(){m(this._cache.mesh)&&(this._cache.mesh.destroy(),this._cache.mesh=null),m(this._cache.vao)&&(this._cache.vao.dispose(),this._cache.vao=null)}destroy(){this._destroyGL(),this._handle.remove()}getVAO(e,t,s,r){const[i,n]=t.size;if(this._clip.type!=="geometry"&&this._lastWidth===i&&this._lastHeight===n||(this._lastWidth=i,this._lastHeight=n,this._destroyGL()),L(this._cache.vao)){const a=this._createMesh(t,this._clip),h=a.getIndexBuffer(e),p=a.getVertexBuffers(e);this._cache.mesh=a,this._cache.vao=new D(e,s,r,p,h)}return this._cache.vao}_createTransforms(){return{dvs:P()}}_invalidate(){this._destroyGL(),this.requestRender()}_createScreenRect(e,t){const[s,r]=e.size,i=typeof t.left=="string"?u(t.left)*s:t.left,n=typeof t.right=="string"?u(t.right)*s:t.right,a=typeof t.top=="string"?u(t.top)*r:t.top,h=typeof t.bottom=="string"?u(t.bottom)*r:t.bottom,p=i,l=a;return{x:p,y:l,width:Math.max(s-n-p,0),height:Math.max(r-h-l,0)}}_createMesh(e,t){switch(t.type){case"rect":return f.fromRect(this._createScreenRect(e,t));case"path":return f.fromPath(t);case"geometry":return f.fromGeometry(e,t);default:return Q.error(new y("mapview-bad-type","Unable to create ClippingInfo mesh from clip of type: ${clip.type}")),f.fromRect({x:0,y:0,width:1,height:1})}}}class X extends q{constructor(){super(...arguments),this.name=this.constructor.name}set clips(e){this._clips=e,this.children.forEach(t=>t.clips=e),this._updateClippingInfo()}_createTransforms(){return{dvs:P()}}doRender(e){const t=this.createRenderParams(e),{painter:s,globalOpacity:r,profiler:i,drawPhase:n}=t,a=n===d.LABEL||n===d.HIGHLIGHT?1:r*this.computedOpacity;i.recordContainerStart(this.name),s.beforeRenderLayer(t,this._clippingInfos?255:0,a),this.updateTransforms(e.state),this.renderChildren(t),s.compositeLayer(t,a),i.recordContainerEnd()}renderChildren(e){L(this._renderPasses)&&(this._renderPasses=this.prepareRenderPasses(e.painter));for(const t of this.children)t.beforeRender(e);for(const t of this._renderPasses)try{t.render(e)}catch{}for(const t of this.children)t.afterRender(e)}createRenderParams(e){return e.requireFBO=this.requiresDedicatedFBO,e}prepareRenderPasses(e){return[e.registerRenderPass({name:"clip",brushes:[O.clip],target:()=>this._clippingInfos,drawPhase:d.MAP|d.LABEL|d.LABEL_ALPHA|d.DEBUG|d.HIGHLIGHT})]}updateTransforms(e){for(const t of this.children)t.setTransform(e)}onAttach(){super.onAttach(),this._updateClippingInfo()}onDetach(){super.onDetach(),this._updateClippingInfo()}_updateClippingInfo(){if(m(this._clippingInfos)&&(this._clippingInfos.forEach(t=>t.destroy()),this._clippingInfos=null),!this.stage)return;const e=this._clips;m(e)&&e.length&&(this._clippingInfos=e.items.map(t=>g.fromClipArea(this.stage,t))),this.requestRender()}}export{X as a};
