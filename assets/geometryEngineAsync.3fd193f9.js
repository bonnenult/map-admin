var A=Object.defineProperty,h=Object.defineProperties;var v=Object.getOwnPropertyDescriptors;var y=Object.getOwnPropertySymbols;var S=Object.prototype.hasOwnProperty,R=Object.prototype.propertyIsEnumerable;var m=(e,r,t)=>r in e?A(e,r,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[r]=t,u=(e,r)=>{for(var t in r||(r={}))S.call(r,t)&&m(e,t,r[t]);if(y)for(var t of y(r))R.call(r,t)&&m(e,t,r[t]);return e},f=(e,r)=>h(e,v(r));import{e0 as w,iD as b,aA as l}from"./index.fe92decb.js";import"./vendor.d9e807b5.js";import"./index.dbbecfd7.js";/* empty css              */import"./qrcode.0911187d.js";/* empty css                 */function a(e){var r;return Array.isArray(e)?(r=e[0])==null?void 0:r.spatialReference:e==null?void 0:e.spatialReference}function g(e){return e&&(Array.isArray(e)?e.map(g):e.toJSON?e.toJSON():e)}function o(e){return Array.isArray(e)?e.map(r=>w(r)):w(e)}function j(e,r){let t;return Array.isArray(e)?t=e:(t=[],t.push(e),r!=null&&t.push(r)),t}let d;async function O(){return d||(d=b("geometryEngineWorker",{strategy:"distributed"})),d}async function n(e,r){return(await O()).invoke("executeGEOperation",{operation:e,parameters:g(r)})}function H(e){return n("extendedSpatialReferenceInfo",[e])}async function L(e,r){return o(await n("clip",[a(e),e,r]))}async function k(e,r){return o(await n("cut",[a(e),e,r]))}function q(e,r){return n("contains",[a(e),e,r])}function B(e,r){return n("crosses",[a(e),e,r])}function C(e,r,t){return n("distance",[a(e),e,r,t])}function $(e,r){return n("equals",[a(e),e,r])}function G(e,r){return n("intersects",[a(e),e,r])}function W(e,r){return n("touches",[a(e),e,r])}function F(e,r){return n("within",[a(e),e,r])}function K(e,r){return n("disjoint",[a(e),e,r])}function M(e,r){return n("overlaps",[a(e),e,r])}function P(e,r,t){return n("relate",[a(e),e,r,t])}function U(e){return n("isSimple",[a(e),e])}async function Q(e){return o(await n("simplify",[a(e),e]))}async function T(e,r=!1){return o(await n("convexHull",[a(e),e,r]))}async function X(e,r){return o(await n("difference",[a(e),e,r]))}async function Y(e,r){return o(await n("symmetricDifference",[a(e),e,r]))}async function Z(e,r){return o(await n("intersect",[a(e),e,r]))}async function _(e,r=null){const t=j(e,r);return o(await n("union",[a(t),t]))}async function ee(e,r,t,i,s,c){return o(await n("offset",[a(e),e,r,t,i,s,c]))}async function re(e,r,t,i=!1){const s=[a(e),e,r,t,i];return o(await n("buffer",s))}async function te(e,r,t,i,s,c){const x=[a(e),e,r,t,i,s,c];return o(await n("geodesicBuffer",x))}async function ne(e,r,t=!0){const i=await n("nearestCoordinate",[a(e),e,r,t]);return f(u({},i),{coordinate:l.fromJSON(i.coordinate)})}async function ae(e,r){const t=await n("nearestVertex",[a(e),e,r]);return f(u({},t),{coordinate:l.fromJSON(t.coordinate)})}async function ie(e,r,t,i){return(await n("nearestVertices",[a(e),e,r,t,i])).map(s=>f(u({},s),{coordinate:l.fromJSON(s.coordinate)}))}function p(e){return"xmin"in e?e.center:"x"in e?e:e.extent.center}async function se(e,r,t){var i;if(e==null)throw new Error("Illegal Argument Exception");const s=e.spatialReference;t=(i=t)!=null?i:p(e);const c=e.constructor.fromJSON(await n("rotate",[s,e,r,t]));return c.spatialReference=s,c}async function oe(e,r){var t;if(e==null)throw new Error("Illegal Argument Exception");const i=e.spatialReference;r=(t=r)!=null?t:p(e);const s=e.constructor.fromJSON(await n("flipHorizontal",[i,e,r]));return s.spatialReference=i,s}async function ce(e,r){var t;if(e==null)throw new Error("Illegal Argument Exception");const i=e.spatialReference;r=(t=r)!=null?t:p(e);const s=e.constructor.fromJSON(await n("flipVertical",[i,e,r]));return s.spatialReference=i,s}async function ue(e,r,t,i){return o(await n("generalize",[a(e),e,r,t,i]))}async function fe(e,r,t){return o(await n("densify",[a(e),e,r,t]))}async function le(e,r,t,i=0){return o(await n("geodesicDensify",[a(e),e,r,t,i]))}function de(e,r){return n("planarArea",[a(e),e,r])}function pe(e,r){return n("planarLength",[a(e),e,r])}function ye(e,r,t){return n("geodesicArea",[a(e),e,r,t])}function me(e,r,t){return n("geodesicLength",[a(e),e,r,t])}export{re as buffer,L as clip,q as contains,T as convexHull,B as crosses,k as cut,fe as densify,X as difference,K as disjoint,C as distance,$ as equals,H as extendedSpatialReferenceInfo,oe as flipHorizontal,ce as flipVertical,ue as generalize,ye as geodesicArea,te as geodesicBuffer,le as geodesicDensify,me as geodesicLength,Z as intersect,G as intersects,U as isSimple,ne as nearestCoordinate,ae as nearestVertex,ie as nearestVertices,ee as offset,M as overlaps,de as planarArea,pe as planarLength,P as relate,se as rotate,Q as simplify,Y as symmetricDifference,W as touches,_ as union,F as within};
