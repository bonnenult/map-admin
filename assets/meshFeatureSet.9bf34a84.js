var Ge=Object.defineProperty,Xe=Object.defineProperties;var Ye=Object.getOwnPropertyDescriptors;var we=Object.getOwnPropertySymbols;var Je=Object.prototype.hasOwnProperty,We=Object.prototype.propertyIsEnumerable;var be=(e,n,t)=>n in e?Ge(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,ee=(e,n)=>{for(var t in n||(n={}))Je.call(n,t)&&be(e,t,n[t]);if(we)for(var t of we(n))We.call(n,t)&&be(e,t,n[t]);return e},te=(e,n)=>Xe(e,Ye(n));import{X as N,r as p,iL as P,a5 as x,gm as ne,aA as O,qX as _e,mN as He,ib as Ve,bg as Ke,T as Qe,t as G,an as re,ay as oe,eH as Ae,eS as se,fH as $e,fo as J,lD as ie,lE as ae,lF as le,lw as ce,lA as ue,lB as fe,eI as Re,f4 as pe,qY as et,qZ as C,iO as tt,aw as Fe,gg as W,pe as Me,i4 as nt,ln as rt,f5 as ot,az as Oe,bF as st,fa as it,ew as at,mw as lt,q_ as he,jm as ct,a8 as ge,v as ut,q$ as ft,e as b,d as F,i as pt,bN as me,fS as ht,h as gt}from"./index.fe92decb.js";import{a as X,q as de,l as xe,x as mt,k as _}from"./axisAngleDegrees.448696be.js";import{r as H,k as dt,x as xt,b as yt,O as V}from"./georeference.884d9fd2.js";import"./vendor.d9e807b5.js";import"./index.dbbecfd7.js";/* empty css              */import"./qrcode.0911187d.js";/* empty css                 */const ye=N.getLogger("esri.geometry.support.meshUtils.centerAt");function vt(e,n,t){var r;if(!e.vertexAttributes||!e.vertexAttributes.position)return;const o=(r=t==null?void 0:t.origin)!=null?r:e.origin;p(e.transform)?((t==null?void 0:t.geographic)!=null&&t.geographic!==e.transform.geographic&&ye.warn(`Specifying the 'geographic' parameter (${t.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`),wt(e.transform,n,o)):H(e.spatialReference,t)?bt(e,n,o):At(e,n,o)}function wt(e,n,t){const r=n.x-t.x,o=n.y-t.y,i=n.hasZ&&t.hasZ?n.z-t.z:0,s=e.origin;e.origin=[s[0]+r,s[1]+o,s[2]+i]}function bt(e,n,t){const r=dt(e.vertexAttributes,t,{geographic:!0}),{position:o,normal:i,tangent:s}=xt(r,n,{geographic:!0});e.vertexAttributes.position=o,e.vertexAttributes.normal=i,e.vertexAttributes.tangent=s,e.vertexAttributesChanged()}function At(e,n,t){const r=Ft,o=Rt;if(P(n,o,e.spatialReference)){if(!P(t,r,e.spatialReference)){const i=e.origin;r[0]=i.x,r[1]=i.y,r[2]=i.z,ye.error(`Failed to project specified origin (wkid:${t.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}$t(e.vertexAttributes.position,o,r),e.vertexAttributesChanged()}else ye.error(`Failed to project centerAt location (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid})`)}function $t(e,n,t){if(e)for(let r=0;r<e.length;r+=3)for(let o=0;o<3;o++)e[r+o]+=n[o]-t[o]}const Rt=x(),Ft=x();async function Mt(e,n,t){const{loadGLTFMesh:r}=await ne(import("./loadGLTFMesh.354b5bd8.js"),t),o=await je(n,t),i=r(new O({x:0,y:0,z:0,spatialReference:e.spatialReference}),o.url,{resolveFile:Ot(o),useTransform:!0,signal:p(t)?t.signal:null});i.then(()=>o.dispose(),()=>o.dispose());const{vertexAttributes:s,components:a}=await i;e.vertexAttributes=s,e.components=a}function Ot(e){const n=He(e.url);return t=>{var r;const o=_e(t,n,n),i=o?o.replace(/^ *\.\//,""):null;return(r=e.files.get(i))!=null?r:t}}async function je(e,n){return e instanceof Blob?S.fromBlob(e):typeof e=="string"?new S(e):Array.isArray(e)?jt(e,n):zt(e,n)}async function jt(e,n){const t=new Map;let r=null;const o=await Ve(e.map(async s=>({name:s.name,source:await je(s instanceof Blob?s:s.source,n)}))),i=[];for(const s of o)s&&(Ke(n)?s.source.dispose():i.push(s));Qe(n);for(const{name:s,source:a}of i)(G(r)||/\.(gltf|glb)/i.test(s))&&(r=a.url),t.set(s,a.url),a.files&&a.files.forEach((l,c)=>t.set(c,l));if(G(r))throw new re("mesh-load-external:missing-files","Missing files to load external mesh source");return new S(r,()=>i.forEach(({source:s})=>s.dispose()),t)}async function zt(e,n){const{default:t}=await ne(import("./index.fe92decb.js").then(function(o){return o.ts}),n),r=typeof e.multipart[0]=="string"?await Promise.all(e.multipart.map(async o=>(await t(o,{responseType:"array-buffer"})).data)):e.multipart;return S.fromBlob(new Blob(r))}class S{constructor(n,t=()=>{},r=new Map){this.url=n,this.dispose=t,this.files=r}static fromBlob(n){const t=URL.createObjectURL(n);return new S(t,()=>URL.revokeObjectURL(t))}}const Pt=N.getLogger("esri.geometry.support.meshUtils.offset");function Lt(e,n,t){e.vertexAttributes&&e.vertexAttributes.position&&(p(e.transform)?((t==null?void 0:t.geographic)!=null&&t.geographic!==e.transform.geographic&&Pt.warn(`Specifying the 'geographic' parameter (${t.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`),kt(e.transform,n)):H(e.spatialReference,t)?Ct(e,n):St(e,n))}function kt(e,n){const t=e.origin;e.origin=oe(x(),t,n)}function Ct(e,n){const t=e.spatialReference,r=e.vertexAttributes.position,o=e.vertexAttributes.normal,i=e.vertexAttributes.tangent,s=new Float64Array(r.length),a=p(o)?new Float32Array(o.length):null,l=p(i)?new Float32Array(i.length):null,c=e.extent.center,u=It;Ae(t,[c.x,c.y,c.z],Pe,se(t)),$e(Le,Pe),J(u,n,Le),ie(r,t,s),p(o)&&ae(o,r,s,t,a),p(i)&&le(i,r,s,t,l),ze(s,u),ce(s,r,t),p(o)&&ue(a,r,s,t,o),p(i)&&fe(l,r,s,t,i),e.vertexAttributesChanged()}function St(e,n){ze(e.vertexAttributes.position,n),e.vertexAttributesChanged()}function ze(e,n){if(e)for(let t=0;t<e.length;t+=3)for(let r=0;r<3;r++)e[t+r]+=n[r]}const It=x(),Pe=Re(),Le=pe();function Tt(){const{faceDescriptions:e,faceVertexOffsets:n,uvScales:t}=Gt,r=4*e.length,o=new Float64Array(3*r),i=new Float32Array(3*r),s=new Float32Array(2*r),a=new Uint32Array(2*e.length*3);let l=0,c=0,u=0,g=0;for(let h=0;h<e.length;h++){const f=e[h],v=l/3;for(const d of n)a[g++]=v+d;const j=f.corners;for(let d=0;d<4;d++){const $=j[d];let w=0;s[u++]=.25*t[d][0]+f.uvOrigin[0],s[u++]=f.uvOrigin[1]-.25*t[d][1];for(let R=0;R<3;R++)f.axis[R]!==0?(o[l++]=.5*f.axis[R],i[c++]=f.axis[R]):(o[l++]=.5*$[w++],i[c++]=0)}}return{position:o,normal:i,uv:s,faces:a}}function Ut(e,n){const t=e.components[0],r=t.faces,o=Xt[n],i=6*o,s=new Uint32Array(6),a=new Uint32Array(r.length-6);let l=0,c=0;for(let u=0;u<r.length;u++)u>=i&&u<i+6?s[l++]=r[u]:a[c++]=r[u];if(p(e.vertexAttributes.uv)){const u=new Float32Array(e.vertexAttributes.uv),g=4*o*2,h=[0,1,1,1,1,0,0,0];for(let f=0;f<h.length;f++)u[g+f]=h[f];e.vertexAttributes.uv=u}return e.components=[new C({faces:s,material:t.material}),new C({faces:a})],e}function Et(e=0){const n=Math.round(8*2**e),t=2*n,r=(n-1)*(t+1)+2*t,o=new Float64Array(3*r),i=new Float32Array(3*r),s=new Float32Array(2*r),a=new Uint32Array(3*((n-1)*t*2));let l=0,c=0,u=0,g=0;for(let h=0;h<=n;h++){const f=h/n*Math.PI+.5*Math.PI,v=Math.cos(f),j=Math.sin(f);m[2]=j;const d=h===0||h===n,$=d?t-1:t;for(let w=0;w<=$;w++){const R=w/$*2*Math.PI;m[0]=-Math.sin(R)*v,m[1]=Math.cos(R)*v;for(let z=0;z<3;z++)o[l]=.5*m[z],i[l]=m[z],++l;s[c++]=(w+(d?.5:0))/t,s[c++]=h/n,h!==0&&w!==t&&(h!==n&&(a[u++]=g,a[u++]=g+1,a[u++]=g-t),h!==1&&(a[u++]=g,a[u++]=g-t,a[u++]=g-t-1)),g++}}return{position:o,normal:i,uv:s,faces:a}}function Bt(e=0){const n=5,t=Math.round(16*2**e),r=(n-1)*(t+1)+2*t,o=new Float64Array(3*r),i=new Float32Array(3*r),s=new Float32Array(2*r),a=new Uint32Array(3*(4*t));let l=0,c=0,u=0,g=0,h=0;for(let f=0;f<=n;f++){const v=f===0||f===n,j=f<=1||f>=n-1,d=f===2||f===4,$=v?t-1:t;for(let w=0;w<=$;w++){const R=w/$*2*Math.PI,z=v?0:.5;m[0]=z*Math.sin(R),m[1]=z*-Math.cos(R),m[2]=f<=2?.5:-.5;for(let k=0;k<3;k++)o[l++]=m[k],i[c++]=j?k===2?f<=1?1:-1:0:k===2?0:m[k]/z;s[u++]=(w+(v?.5:0))/t,s[u++]=f<=1?1*f/3:f<=3?1*(f-2)/3+1/3:1*(f-4)/3+2/3,d||f===0||w===t||(f!==n&&(a[g++]=h,a[g++]=h+1,a[g++]=h-t),f!==1&&(a[g++]=h,a[g++]=h-t,a[g++]=h-t-1)),h++}}return{position:o,normal:i,uv:s,faces:a}}function qt(e,n){const t=typeof n=="number"?n:n!=null?n.width:1,r=typeof n=="number"?n:n!=null?n.height:1;switch(e){case"up":case"down":return{width:t,depth:r};case"north":case"south":return{width:t,height:r};case"east":case"west":return{depth:t,height:r}}}function Zt(e){const n=Y.facingAxisOrderSwap[e],t=Y.position,r=Y.normal,o=new Float64Array(t.length),i=new Float32Array(r.length);let s=0;for(let a=0;a<4;a++){const l=s;for(let c=0;c<3;c++){const u=n[c],g=Math.abs(u)-1,h=u>=0?1:-1;o[s]=t[l+g]*h,i[s]=r[l+g]*h,s++}}return{position:o,normal:i,uv:new Float32Array(Y.uv),faces:new Uint32Array(Y.faces)}}const I=1,T=2,U=3,Y={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[U,I,T],west:[-U,-I,T],north:[-I,U,T],south:[I,-U,T],up:[I,T,U],down:[I,-T,-U]}};function K(e,n,t){Dt(e),Nt(e,t&&t.size);const{vertexAttributes:r,transform:o}=yt(e,n,t);return{vertexAttributes:new et(te(ee({},r),{uv:e.uv})),transform:o,components:[new C({faces:e.faces,material:t&&t.material||null})],spatialReference:n.spatialReference}}function Dt(e){for(let n=0;n<e.position.length;n+=3)e.position[n+2]+=.5}function Nt(e,n){if(n==null)return;const t=typeof n=="number"?[n,n,n]:[n.width!=null?n.width:1,n.depth!=null?n.depth:1,n.height!=null?n.height:1];L[0]=t[0],L[4]=t[1],L[8]=t[2];for(let r=0;r<e.position.length;r+=3){for(let o=0;o<3;o++)m[o]=e.position[r+o];J(m,m,L);for(let o=0;o<3;o++)e.position[r+o]=m[o]}if(t[0]!==t[1]||t[1]!==t[2]){L[0]=1/t[0],L[4]=1/t[1],L[8]=1/t[2];for(let r=0;r<e.normal.length;r+=3){for(let o=0;o<3;o++)m[o]=e.normal[r+o];J(m,m,L),tt(m,m);for(let o=0;o<3;o++)e.normal[r+o]=m[o]}}}const Gt={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},Xt={south:0,east:1,north:2,west:3,up:4,down:5},m=x(),L=pe(),ke=N.getLogger("esri.geometry.support.meshUtils.rotate");function Yt(e,n,t){if(!e.vertexAttributes||!e.vertexAttributes.position||n[3]===0)return;const r=e.spatialReference;if(p(e.transform)){var o;(t==null?void 0:t.geographic)!=null&&t.geographic!==e.transform.geographic&&ke.warn(`Specifying the 'geographic' parameter (${t.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`);const s=(o=t==null?void 0:t.origin)!=null?o:e.transform.getOriginPoint(r);Jt(e.transform,n,s)}else{var i;const s=(i=t==null?void 0:t.origin)!=null?i:e.origin;H(e.spatialReference,t)?Wt(e,n,s):_t(e,n,s)}}function Jt(e,n,t){const r=Fe(B,t.x,t.y,t.z),o=W(B,r,e.origin);e.applyLocalInverse(o,Ce),e.rotation=de(e.rotation,n,X()),e.applyLocalInverse(o,o),W(o,o,Ce),e.translation=oe(x(),e.translation,o)}function Wt(e,n,t){const r=e.spatialReference,o=se(r),i=Te;P(t,i,o)||P(e.origin,i,o);const s=e.vertexAttributes.position,a=e.vertexAttributes.normal,l=e.vertexAttributes.tangent,c=new Float64Array(s.length),u=p(a)?new Float32Array(a.length):null,g=p(l)?new Float32Array(l.length):null;Ae(o,i,q,o),$e(Ie,q);const h=Se;J(xe(Se),xe(n),Ie),h[3]=n[3],ie(s,r,c),p(a)&&ae(a,s,c,r,u),p(l)&&le(l,s,c,r,g),E(c,h,3,i),ce(c,s,r),p(a)&&(E(u,h,3),ue(u,s,c,r,a)),p(l)&&(E(g,h,4),fe(g,s,c,r,l)),e.vertexAttributesChanged()}function _t(e,n,t){const r=Te;if(!P(t,r,e.spatialReference)){const o=e.origin;r[0]=o.x,r[1]=o.y,r[2]=o.z,ke.error(`Failed to project specified origin (wkid:${t.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}E(e.vertexAttributes.position,n,3,r),E(e.vertexAttributes.normal,n,3),E(e.vertexAttributes.tangent,n,4),e.vertexAttributesChanged()}function E(e,n,t,r=Me){if(!G(e)){nt(q),rt(q,q,mt(n),xe(n));for(let o=0;o<e.length;o+=t){for(let i=0;i<3;i++)B[i]=e[o+i]-r[i];ot(B,B,q);for(let i=0;i<3;i++)e[o+i]=B[i]+r[i]}}}const B=x(),Ce=x(),Se=X(),q=Re(),Ie=pe(),Te=x(),Ue=N.getLogger("esri.geometry.support.meshUtils.scale");function Ht(e,n,t){if(!e.vertexAttributes||!e.vertexAttributes.position)return;const r=e.spatialReference;if(p(e.transform)){var o;(t==null?void 0:t.geographic)!=null&&t.geographic!==e.transform.geographic&&Ue.warn(`Specifying the 'geographic' parameter (${t.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`);const i=(o=t==null?void 0:t.origin)!=null?o:e.transform.getOriginPoint(r);Vt(e.transform,n,i)}else{const i=H(e.spatialReference,t),s=t&&t.origin||e.origin;i?Kt(e,n,s):Qt(e,n,s)}}function Vt(e,n,t){const r=Fe(Z,t.x,t.y,t.z),o=W(Z,r,e.origin);e.applyLocalInverse(o,Be);const i=Oe(x(),e.scale,n);e.scale=i,e.applyLocalInverse(o,o),W(o,o,Be),e.translation=oe(x(),e.translation,o)}function Kt(e,n,t){const r=e.spatialReference,o=se(r),i=qe;P(t,i,o)||P(e.origin,i,o);const s=e.vertexAttributes.position,a=e.vertexAttributes.normal,l=e.vertexAttributes.tangent,c=new Float64Array(s.length),u=p(a)?new Float32Array(a.length):null,g=p(l)?new Float32Array(l.length):null;ie(s,r,c),p(a)&&ae(a,s,c,r,u),p(l)&&le(l,s,c,r,g),Ee(c,n,i),ce(c,s,r),p(a)&&ue(u,s,c,r,a),p(l)&&fe(g,s,c,r,l),e.vertexAttributesChanged()}function Qt(e,n,t){const r=qe;if(!P(t,r,e.spatialReference)){const o=e.origin;r[0]=o.x,r[1]=o.y,r[2]=o.z,Ue.error(`Failed to project specified origin (wkid:${t.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}Ee(e.vertexAttributes.position,n,r),e.vertexAttributesChanged()}function Ee(e,n,t=Me){if(e)for(let r=0;r<e.length;r+=3){for(let o=0;o<3;o++)Z[o]=e[r+o]-t[o];Oe(Z,Z,n);for(let o=0;o<3;o++)e[r+o]=Z[o]+t[o]}}const Z=x(),Be=x(),qe=x();var M;const A=N.getLogger("esri.geometry.Mesh");let y=M=class extends st(it.LoadableMixin(at(lt))){constructor(e){super(e),this.components=null,this.transform=null,this.external=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new he,this.type="mesh"}initialize(){(G(this.external)||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when(()=>{this.handles.add(ct(()=>{var e;return{vertexAttributes:this.vertexAttributes,components:(e=this.components)==null?void 0:e.map(n=>n.clone()),transform:p(this.transform)?this.transform.clone():null}},()=>this._set("external",null),{once:!0,sync:!0}))})}get hasExtent(){return!this.loaded&&p(this.external)&&p(this.external.extent)||this.loaded&&this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0)}get boundingInfo(){const e=this.vertexAttributes.position,n=this.spatialReference;if(e.length===0||this.components&&this.components.length===0)return{extent:new ge({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:n}),center:new O({x:0,y:0,z:0,spatialReference:n})};const t=p(this.transform)?this.transform.project(e,n):e;let r=1/0,o=1/0,i=1/0,s=-1/0,a=-1/0,l=-1/0,c=0,u=0,g=0;const h=t.length,f=1/(h/3);let v=0;for(;v<h;){const j=t[v++],d=t[v++],$=t[v++];r=Math.min(r,j),o=Math.min(o,d),i=Math.min(i,$),s=Math.max(s,j),a=Math.max(a,d),l=Math.max(l,$),c+=f*j,u+=f*d,g+=f*$}return{extent:new ge({xmin:r,ymin:o,zmin:i,xmax:s,ymax:a,zmax:l,spatialReference:n}),center:new O({x:c,y:u,z:g,spatialReference:n})}}get anchor(){if(p(this.transform))return this.transform.getOriginPoint(this.spatialReference);const e=this.boundingInfo;return new O({x:e.center.x,y:e.center.y,z:e.extent.zmin,spatialReference:this.spatialReference})}get origin(){return p(this.transform)?this.transform.getOriginPoint(this.spatialReference):this.boundingInfo.center}get extent(){return!this.loaded&&p(this.external)&&p(this.external.extent)?this.external.extent.clone():this.boundingInfo.extent}addComponent(e){this.loaded?(this.components||(this.components=[]),this.components.push(C.from(e)),this.notifyChange("components")):A.error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(e){if(this.loaded){if(this.components){const n=this.components.indexOf(e);if(n!==-1)return this.components.splice(n,1),void this.notifyChange("components")}A.error("removeComponent()","Provided component is not part of the list of components")}else A.error("removeComponent()","Mesh must be loaded before applying operations")}rotate(e,n,t,r){return _(ve.x,e,D),_(ve.y,n,Ze),_(ve.z,t,De),de(D,Ze,D),de(D,De,D),Yt(this,D,r),this}offset(e,n,t,r){return this.loaded?(Q[0]=e,Q[1]=n,Q[2]=t,Lt(this,Q,r),this):(A.error("offset()","Mesh must be loaded before applying operations"),this)}scale(e,n){return this.loaded?(Ht(this,e,n),this):(A.error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(e,n){return this.loaded?(vt(this,e,n),this):(A.error("centerAt()","Mesh must be loaded before applying operations"),this)}load(e){return p(this.external)&&this.addResolvingPromise(Mt(this,this.external.source,e)),Promise.resolve(this)}clone(){const e=this.components?new Map:null,n=this.components?new Map:null,t={components:this.components?this.components.map(r=>r.cloneWithDeduplication(e,n)):null,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),transform:p(this.transform)?this.transform.clone():null,external:p(this.external)?{source:this.external.source,extent:p(this.external.extent)?this.external.extent.clone():null}:null};return new M(t)}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(e){const{toBinaryGLTF:n}=await import("./gltfexport.03037400.js");return n(this,e)}static createBox(e,n){if(!(e instanceof O))return A.error(".createBox()","expected location to be a Point instance"),null;const t=new M(K(Tt(),e,n));return n&&n.imageFace&&n.imageFace!=="all"?Ut(t,n.imageFace):t}static createSphere(e,n){return e instanceof O?new M(K(Et(n&&n.densificationFactor||0),e,n)):(A.error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(e,n){return e instanceof O?new M(K(Bt(n&&n.densificationFactor||0),e,n)):(A.error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(e,n){var t;if(!(e instanceof O))return A.error(".createPlane()","expected location to be a Point instance"),null;const r=(t=n==null?void 0:n.facing)!=null?t:"up",o=qt(r,n==null?void 0:n.size);return new M(K(Zt(r),e,te(ee({},n),{size:o})))}static createFromPolygon(e,n){if(!(e instanceof ut))return A.error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const t=ft(e);return new M({vertexAttributes:new he({position:t.position}),components:[new C({faces:t.faces,shading:"flat",material:n&&n.material||null})],spatialReference:e.spatialReference})}static async createFromGLTF(e,n,t){if(!(e instanceof O))throw A.error(".createfromGLTF()","expected location to be a Point instance"),new re("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:r}=await ne(import("./loadGLTFMesh.354b5bd8.js"),t);return new M(await r(e,n,t))}static createWithExternalSource(e,n,t){var r,o,i;const s=(r=t==null?void 0:t.extent)!=null?r:null,a=(o=t==null?void 0:t.transform.clone())!=null?o:new V;a.origin=[e.x,e.y,(i=e.z)!=null?i:0];const l=e.spatialReference;return new M({external:{source:n,extent:s},transform:a,spatialReference:l})}static createIncomplete(e,n){var t,r;const o=(t=n==null?void 0:n.transform.clone())!=null?t:new V;o.origin=[e.x,e.y,(r=e.z)!=null?r:0];const i=e.spatialReference,s=new M({transform:o,spatialReference:i});return s.addResolvingPromise(Promise.reject(new re("mesh-incomplete","Mesh resources are not complete"))),s}};b([F({type:[C],json:{write:!0}})],y.prototype,"components",void 0),b([F({type:V,json:{write:!0}})],y.prototype,"transform",void 0),b([F({constructOnly:!0})],y.prototype,"external",void 0),b([F({readOnly:!0})],y.prototype,"hasExtent",null),b([F({readOnly:!0})],y.prototype,"boundingInfo",null),b([F({readOnly:!0})],y.prototype,"anchor",null),b([F({readOnly:!0})],y.prototype,"origin",null),b([F({readOnly:!0,json:{read:!1}})],y.prototype,"extent",null),b([F({readOnly:!0,json:{read:!1,write:!0,default:!0}})],y.prototype,"hasZ",void 0),b([F({readOnly:!0,json:{read:!1,write:!0,default:!1}})],y.prototype,"hasM",void 0),b([F({type:he,nonNullable:!0,json:{write:!0}})],y.prototype,"vertexAttributes",void 0),y=M=b([pt("esri.geometry.Mesh")],y);const ve={x:me(1,0,0),y:me(0,1,0),z:me(0,0,1)},D=X(),Ze=X(),De=X(),Q=x(),Ne=y;function mn(e,n,t){const r=t.features;t.features=[],delete t.geometryType;const o=ht.fromJSON(t);o.geometryType="mesh";const i=o.spatialReference,s=G(e.outFields)||!e.outFields.length?()=>({}):en(e.outFields.includes("*")?null:new Set(e.outFields));for(const a of r){const l=tn(a,i,n);p(l)&&o.features.push(new gt({geometry:l,attributes:s(a)}))}return o}function en(e){return({attributes:n})=>{if(!n)return{};if(!e)return n;for(const t in n)e.has(t)||delete n[t];return n}}function tn(e,n,t){const{status:r,source:o}=on(e);if(r===0)return null;const i=nn(e,n,t),s=ge.fromJSON(e.geometry);s.spatialReference=n;const a=rn(e,t);return r===1?Ne.createIncomplete(i,{extent:s,transform:a}):Ne.createWithExternalSource(i,o,{extent:s,transform:a})}function nn({attributes:e},n,{transformFieldRoles:t}){return new O({x:e[t.originX],y:e[t.originY],z:e[t.originZ],spatialReference:n})}function rn({attributes:e,assetMappings:n},{transformFieldRoles:t}){var r;return new V({translation:[e[t.translationX],e[t.translationY],e[t.translationZ]],rotation:_([e[t.rotationX],e[t.rotationY],e[t.rotationZ]],e[t.rotationDeg]),scale:[e[t.scaleX],e[t.scaleY],e[t.scaleZ]],geographic:!((r=n.flags)!=null&&r.includes("PROJECT_VERTICES"))})}function on(e){if(!e.assetMappings)return{status:0};const n=[],t=new Map;for(const r of e.assetMappings){const o=r.seqNo,i=r.assetName,s=r.assetURL,a=r.conversionStatus;if(a==="FAILED")return{status:0};if(a!=="COMPLETED")return{status:1};if(o==null)n.push({name:i,source:s});else{const l=t.get(i);let c;l?c=l.multipart:(c=[],n.push({name:i,source:{multipart:c}}),t.set(i,{multipart:c})),c[o]=s}}return{status:2,source:n}}export{mn as meshFeatureSetFromJSON};
